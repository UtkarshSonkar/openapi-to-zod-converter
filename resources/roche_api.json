{
  "openapi":"3.0.1",
  "info":{
     "title":"Fortanix DSM REST API",
     "description":"This is a set of REST APIs for accessing the Fortanix Data Security Manager. This includes APIs for managing accounts, and for performing cryptographic and key management operations.\n",
     "termsOfService":"https://www.fortanix.com/legal/terms/",
     "contact":{
        "name":"Fortanix Support",
        "url":"https://support.fortanix.com/",
        "email":"support@fortanix.com"
     },
     "license":{
        "name":"Apache 2.0",
        "url":"http://www.apache.org/licenses/LICENSE-2.0.html"
     },
     "version":"1.0.0-20200608"
  },
  "servers":[
     {
        "url":"https://apps.smartkey.io/"
     }
  ],
  "paths":{
     "/sys/v1/version":{
        "get":{
           "tags":[
              "Authentication"
           ],
           "summary":"Get DSM version information",
           "description":"Returns information about the  DSM server version and the client API version that it supports.\n",
           "operationId":"getServerVersion",
           "responses":{
              "200":{
                 "$ref":"#/components/responses/VersionResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           }
        }
     },
     "/sys/v1/health":{
        "get":{
           "tags":[
              "Authentication"
           ],
           "summary":"Check whether the server is handling requests",
           "description":"Returns a 200-class status code if the server is handling requests, or a 500-class status code if the server is having problems.\n",
           "operationId":"checkHealth",
           "responses":{
              "204":{
                 "description":"Nothing is returned on success",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           }
        }
     },
     "/sys/v1/session/auth":{
        "post":{
           "tags":[
              "Authentication"
           ],
           "summary":"Create a session for a user or an app",
           "description":"Authenticate a user or an app to DSM to begin a session. The caller needs to provide a basic authentication token to authenticate to DSM. The response body contains a bearer authentication token which needs to be provided by subsequent calls for the duration of the session.\n",
           "operationId":"authorize",
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AuthResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "basicAuth":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/reauth":{
        "post":{
           "tags":[
              "Authentication"
           ],
           "summary":"Create a new session for a user or an app using an existing session bearer token.",
           "description":"Authenticate a user or an app to DSM using existing session token, to generate a new session. The caller needs to provide bearer authentication token of an existing valid session. The response body contains a bearer authentication token of the new session created.\n",
           "operationId":"reAuth",
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AuthResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/refresh":{
        "post":{
           "tags":[
              "Authentication"
           ],
           "summary":"Refreshes existing user or app session.",
           "description":"Refreshes an existing session, thus extending the expiration time of the existing bearer authentication token. The caller needs to provide bearer token of sesssion need to be refreshed. The response body is empty.\n",
           "operationId":"refresh",
           "responses":{
              "204":{
                 "description":"Nothing is returned on success",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/terminate":{
        "post":{
           "tags":[
              "Authentication"
           ],
           "summary":"Terminate a session",
           "description":"Terminate an authenticated session. After this call, the provided bearer authentication token will be invalidated and cannot be used to make any further API calls.\n",
           "operationId":"terminate",
           "responses":{
              "204":{
                 "description":"Nothing is returned on success",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/select_account":{
        "post":{
           "tags":[
              "Authentication"
           ],
           "summary":"Select a user's account to work on",
           "description":"Select one of user's account to proceed. This is applicable when a user is associated with more than one account. The caller needs to provide a bearer token for the session in the request body.\n",
           "operationId":"selectAccount",
           "requestBody":{
              "$ref":"#/components/requestBodies/SelectAccountRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/SelectAccountResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys":{
        "get":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Get all security objects",
           "description":"Return detailed information about the security objects stored in Fortanix DSM.\n",
           "operationId":"getSecurityObjects",
           "parameters":[
              {
                 "name":"name",
                 "in":"query",
                 "description":"Only retrieve the security object with this name.",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"group_id",
                 "in":"query",
                 "description":"Only retrieve security objects in the specified group.",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"creator",
                 "in":"query",
                 "description":"Only retrieve security objects created by the user or application with the specified id.",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"sort",
                 "in":"query",
                 "description":"This specifies the property (`kid` or `name`) and order (ascending or descending) with which to sort the security objects. By default, security objects are sorted by `kid` in ascending order. The syntax is \"<property>:[asc|desc]\" (e.g. \"kid:desc\") or just \"<property>\" (ascending order by default).\n",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"compliant_with_policies",
                 "in":"query",
                 "description":"Whether this security object is compliant with cryptographic policies or not.",
                 "schema":{
                    "type":"boolean"
                 }
              },
              {
                 "name":"start",
                 "in":"query",
                 "description":"If provided, this must be a value of the property specified in `sort`. Returned security objects will begin just above or just below this value (for asc/desc order resp.).\n",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"limit",
                 "in":"query",
                 "description":"Maximum number of security objects to return. If not provided, the limit is 100.",
                 "schema":{
                    "type":"integer"
                 }
              },
              {
                 "name":"offset",
                 "in":"query",
                 "description":"Number of security objects past `start` to skip.",
                 "schema":{
                    "type":"integer"
                 }
              },
              {
                 "name":"show_destroyed",
                 "in":"query",
                 "description":"Whether security objects in the `Destroyed` state should be returned",
                 "schema":{
                    "type":"boolean"
                 }
              },
              {
                 "name":"show_deleted",
                 "in":"query",
                 "description":"Whether security objects in the `Deleted` state should be returned",
                 "schema":{
                    "type":"boolean"
                 }
              }
           ],
           "responses":{
              "200":{
                 "description":"An array of security objects.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "type":"array",
                          "items":{
                             "$ref":"#/components/schemas/KeyObject"
                          }
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "put":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Import a security object",
           "description":"Import a security object into DSM. <br> By default, all key operations except that are implemented for that type of key will be enabled. These may be overridden by requesting specific operations in the key import request. <br>\nFor symmetric and asymmetric keys, value is base64-encoding of the key material in DER format.\n",
           "operationId":"importSecurityObject",
           "requestBody":{
              "$ref":"#/components/requestBodies/SobjectRequest"
           },
           "responses":{
              "201":{
                 "description":"A newly created security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Generate a new security object",
           "description":"Generate a new security object (such as an RSA key pair or an AES key) of the requested size or elliptic curve. <br>\nBy default, all key operations except for Export that are implemented for that type of key will be enabled. These may be overridden by requesting specific operations in the key creation request. <br>\nObjects of type Opaque may not be generated with this API. They must be imported via the importSecurityObject API.\n",
           "operationId":"generateSecurityObject",
           "requestBody":{
              "$ref":"#/components/requestBodies/SobjectRequest"
           },
           "responses":{
              "201":{
                 "description":"A newly created security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}":{
        "get":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Get a specific security object",
           "description":"Get the details of a particular security object.\n",
           "operationId":"getSecurityObject",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              },
              {
                 "name":"view",
                 "in":"query",
                 "description":"The encoding the value of an opaque object or certificate",
                 "schema":{
                    "type":"string",
                    "default":"json",
                    "enum":[
                       "json",
                       "value"
                    ]
                 }
              },
              {
                 "name":"show_destroyed",
                 "in":"query",
                 "description":"Whether security objects in the `Destroyed` state should be returned",
                 "schema":{
                    "type":"boolean",
                    "default":false
                 }
              },
              {
                 "name":"show_deleted",
                 "in":"query",
                 "description":"Whether security objects in the `Deleted` state should be returned",
                 "schema":{
                    "type":"boolean"
                 }
              }
           ],
           "responses":{
              "200":{
                 "description":"Details about the specified security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "delete":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Delete a security object",
           "description":"Delete a specified security object.",
           "operationId":"deleteSecurityObject",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "patch":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Update a security object",
           "description":"Update the properties of a security object.\n",
           "operationId":"updateSecurityObject",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/SobjectRequest"
           },
           "responses":{
              "200":{
                 "description":"Updated security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/destroy":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Destroys a security object, leaving its metadata in place",
           "description":"Destroys a security object. Objects in the `Destroyed` state cannot be used in any cryptographic operation. Their metadata however, remains present.\n",
           "operationId":"destroySecurityObject",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/info":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Get a specific security object by id or name",
           "description":"Get the details of a particular security object.\n",
           "operationId":"getSecurityObjectEx",
           "parameters":[
              {
                 "name":"view",
                 "in":"query",
                 "description":"The encoding the value of an opaque object or certificate",
                 "schema":{
                    "type":"string",
                    "default":"json",
                    "enum":[
                       "json",
                       "value"
                    ]
                 }
              },
              {
                 "name":"show_destroyed",
                 "in":"query",
                 "description":"Whether security objects in the `Destroyed` state should be returned",
                 "schema":{
                    "type":"boolean",
                    "default":false
                 }
              },
              {
                 "name":"show_deleted",
                 "in":"query",
                 "description":"Whether security objects in the `Deleted` state should be returned",
                 "schema":{
                    "type":"boolean"
                 }
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/GetSecurityObjectRequest"
           },
           "responses":{
              "200":{
                 "description":"Details about the specified security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/kcv":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Get the key check value (KCV) of a symmetric key",
           "description":"Get the key check value (KCV) of a symmetric key",
           "operationId":"getSecurityObjectKcv",
           "requestBody":{
              "$ref":"#/components/requestBodies/SecurityObjectKcvRequest"
           },
           "responses":{
              "200":{
                 "description":"The key check value (KCV) of a symmetric key.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyCheckValueResponse"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/persist":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Persist a transient key.",
           "description":"This API copies a transient key into a persisted security object in DSM. If the transient key's origin is \"FortanixHSM\", the origin of the persisted key will be \"Transient\". If the transient key's origin is \"External\", the origin of the persisted key will be \"External\".\n",
           "operationId":"persistSecurityObject",
           "requestBody":{
              "$ref":"#/components/requestBodies/PersistTransientKeyRequest"
           },
           "responses":{
              "201":{
                 "description":"The persisted security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/private":{
        "delete":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Remove / Destroy private half of the asymmetric key",
           "description":"Removes the private portion of an asymmetric key from DSM. After this operation is performed, operations that require the private key, such as encryption and generating signatures, may no longer be performed.\n",
           "operationId":"deletePrivateKey",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/rekey":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Rotate a key.",
           "description":"Rotate an existing security object.",
           "operationId":"rotateSecurityObject",
           "requestBody":{
              "$ref":"#/components/requestBodies/SobjectRequest"
           },
           "responses":{
              "201":{
                 "description":"A newly created security object that replaces the old one.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/export":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Retrieve the value of an exportable security object",
           "description":"Get the details and value of a particular exportable security object.\n",
           "operationId":"getSecurityObjectValueEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/ExportRequest"
           },
           "responses":{
              "200":{
                 "description":"Details and value of the specified security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/components/export":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"export key components",
           "operationId":"exportSobjectComponents",
           "requestBody":{
              "$ref":"#/components/requestBodies/ExportSobjectComponentsRequest"
           },
           "responses":{
              "200":{
                 "description":"components and value of the specified security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/ExportComponentsResponse"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/components/import":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"import key components",
           "operationId":"importSobjectComponents",
           "requestBody":{
              "$ref":"#/components/requestBodies/ImportSobjectComponentsRequest"
           },
           "responses":{
              "200":{
                 "description":"components and value of the specified security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/digest":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Retrieve the digest (hash) of the value of an exportable security object",
           "operationId":"getSecurityObjectDigest",
           "requestBody":{
              "$ref":"#/components/requestBodies/ObjectDigestRequest"
           },
           "responses":{
              "200":{
                 "description":"Digest of the value of the specified security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/DigestResponse"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/kcv/verify":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Verify that the KCV of the provided key material matches the provided KCV",
           "operationId":"verifyKcv",
           "requestBody":{
              "$ref":"#/components/requestBodies/VerifyKcvRequest"
           },
           "responses":{
              "200":{
                 "description":"True if the KCV provided matches the KCV of the provided key material.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/VerifyKcvResponse"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/export":{
        "get":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Retrieve the value of an exportable security object",
           "description":"Get the details and value of a particular exportable security object.\n",
           "operationId":"getSecurityObjectValue",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "responses":{
              "200":{
                 "description":"Details and value of the specified security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/activate":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Transitions immediately a security object to Active state",
           "description":"Trigger the transition of a security object to Active state.\n",
           "operationId":"activateSecurityObject",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/revoke":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Transitions immediately a security object to Deactivated or Compromised state",
           "description":"Trigger the transition of a security object to Deactivated or Compromised state depending on the RevocationReason Code.\n",
           "operationId":"revokeSecurityObject",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/RevocationReason"
           },
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/revert":{
        "put":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Reverts a security object to a previous state",
           "description":"When a Key Undo Policy is in place, security objects maintain a list of history items. Using this API endpoint, clients may revert the security object to a previous (non-expired) history item.\n",
           "operationId":"revertHistoryItem",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/RevertRequest"
           },
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/encrypt":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Encrypt data",
           "description":"Encrypt data using a symmetric or asymmetric key. <br>\nFor symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br>\nFor GCM and CCM modes, tag_len is a required field. <br>\niv is optional for symmetric ciphers and unused for asymmetric ciphers. If provided, it will be used as the cipher initialization value. Length of iv must match the initialization value size for the cipher and mode. If not provided, DSM will create a random iv of the correct length for the cipher and mode and return this value in the response. <br>\nObjects of type Opaque, EC, or HMAC may not be used for encryption or decryption. <br>\n",
           "operationId":"encrypt",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/EncryptRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/EncryptResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/encrypt":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Encrypt data",
           "description":"Encrypt data using a symmetric or asymmetric key. <br>\nFor symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br>\nFor GCM and CCM modes, tag_len is a required field. <br>\niv is optional for symmetric ciphers and unused for asymmetric ciphers. If provided, it will be used as the cipher initialization value. Length of iv must match the initialization value size for the cipher and mode. If not provided, DSM will create a random iv of the correct length for the cipher and mode and return this value in the response. <br>\nObjects of type Opaque, EC, or HMAC may not be used for encryption or decryption. <br>\n",
           "operationId":"encryptEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/EncryptRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/EncryptResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/batch/encrypt":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Batch encrypt with one or more keys",
           "description":"The data to be encrypted and the key ids to be used are provided in the request body. The encrypted cipher text is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB.\n",
           "operationId":"batchEncrypt",
           "requestBody":{
              "$ref":"#/components/requestBodies/BatchEncryptRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/BatchEncryptResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/encrypt/init":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Begin multi-part encryption",
           "description":"This API is used when encrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part encryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request.\n",
           "operationId":"encryptInit",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/EncryptInitRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/EncryptInitResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/encrypt/init":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Begin multi-part encryption",
           "description":"This API is used when encrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part encryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request.\n",
           "operationId":"encryptInitEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/EncryptInitRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/EncryptInitResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/encrypt/update":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Continue multi-part encryption",
           "description":"Continue a multi-part encryption operation. See `encrypt/init` for details.\n",
           "operationId":"encryptUpdate",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/EncryptUpdateRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/EncryptUpdateResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/encrypt/update":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Continue multi-part encryption",
           "description":"Continue a multi-part encryption operation. See `encrypt/init` for details.\n",
           "operationId":"encryptUpdateEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/EncryptUpdateRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/EncryptUpdateResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/encrypt/final":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Conclude multi-part encryption",
           "description":"Conclude a multi-part encryption operation. See `encrypt/init` for details.\n",
           "operationId":"encryptFinal",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/EncryptFinalRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/EncryptFinalResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/encrypt/final":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Conclude multi-part encryption",
           "description":"Conclude a multi-part encryption operation. See `encrypt/init` for details.\n",
           "operationId":"encryptFinalEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/EncryptFinalRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/EncryptFinalResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/stream/encrypt":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Encrypt a stream of data",
           "description":"Encrypt a stream of data.  Like the multi-part API, this API is used when the data to be encrypted is large (>512KiB), or the size of the data is not known ahead of time.  It supports symmetric ciphers in the ECB, CBC, CBCNOPAD, CFB, OFB, CTR, and GCM modes of operation.  Unlike the multi-part API, a single long-running request is used, where the request and response bodies are streamed simultaneously.  <br>\nBoth the request and response are a sequence of frames, each encoded in CBOR.  The frames are concatenated into a CBOR sequence, following RFC 8742.  The request consists of an \"init\" frame, zero or more \"ad\" frames, one or more \"plain\" frames, and a \"final\" frame.  A successful response consists of an \"init\" frame, one or more \"cipher\" frames, and a \"final\" frame.  <br>\nIf an error occurs processing the \"init\" frame, the error is indicated as an HTTP status code and plain-text body, like all other APIs.  If an error occurs later, it is reported as an \"error\" frame, and no further frames are sent.\n",
           "operationId":"streamEncrypt",
           "requestBody":{
              "$ref":"#/components/requestBodies/StreamEncryptRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/StreamEncryptResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/decrypt":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Decrypt data",
           "description":"Decrypt data using a symmetric or asymmetric key. For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br>\nFor GCM and CCM modes, tag_len is a required field. <br>\niv is required for symmetric ciphers and unused for asymmetric ciphers. It must contain the initialization value used when the object was encrypted. <br>\nObjects of type opaque, EC, or HMAC may not be used for encryption or decryption. <br>\n",
           "operationId":"decrypt",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/DecryptRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DecryptResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/decrypt":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Decrypt data",
           "description":"Decrypt data using a symmetric or asymmetric key. For symmetric ciphers, mode (specifying the block cipher mode) is a required field. <br>\nFor GCM and CCM modes, tag_len is a required field. <br>\niv is required for symmetric ciphers and unused for asymmetric ciphers. It must contain the initialization value used when the object was encrypted. <br>\nObjects of type opaque, EC, or HMAC may not be used for encryption or decryption. <br>\n",
           "operationId":"decryptEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/DecryptRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DecryptResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/batch/decrypt":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Batch decrypt with one or more keys",
           "description":"The data to be decrypted and the key ids to be used are provided in the request body. The decrypted plain text is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB.\n",
           "operationId":"batchDecrypt",
           "requestBody":{
              "$ref":"#/components/requestBodies/BatchDecryptRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/BatchDecryptResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/decrypt/init":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Begin multi-part decryption",
           "description":"This API is used when decrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part decryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request.\n",
           "operationId":"decryptInit",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/DecryptInitRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DecryptInitResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/decrypt/init":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Begin multi-part decryption",
           "description":"This API is used when decrypting more data than the client wishes to submit in a single request. It supports only symmetric ciphers and CBC, CBCNOPAD, CTR, and GCM modes of operation. To perform multi-part decryption, the client makes one request to the `init` resource, zero or more requests to the `update` resource, followed by one request to the `final` resource. The response to init and update requests includes a `state` field. The `state` is an opaque data blob that must be supplied unmodified by the client with the subsequent request.\n",
           "operationId":"decryptInitEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/DecryptInitRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DecryptInitResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/decrypt/update":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Continue multi-part decryption",
           "description":"Continue a multi-part decryption operation. See `decrypt/init` for details.\n",
           "operationId":"decryptUpdate",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/DecryptUpdateRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DecryptUpdateResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/decrypt/update":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Continue multi-part decryption",
           "description":"Continue a multi-part decryption operation. See `decrypt/init` for details.\n",
           "operationId":"decryptUpdateEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/DecryptUpdateRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DecryptUpdateResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/decrypt/final":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Conclude multi-part decryption",
           "description":"Conclude a multi-part decryption operation. See `decrypt/init` for details.\n",
           "operationId":"decryptFinal",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/DecryptFinalRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DecryptFinalResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/decrypt/final":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Conclude multi-part decryption",
           "description":"Conclude a multi-part decryption operation. See `decrypt/init` for details.\n",
           "operationId":"decryptFinalEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/DecryptFinalRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DecryptFinalResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/stream/decrypt":{
        "post":{
           "tags":[
              "Encryption and Decryption"
           ],
           "summary":"Decrypt a stream of data",
           "description":"Decrypt a stream of data.  Like the multi-part API, this API is used when the data to be encrypted is large (>512KiB), or the size of the data is not known ahead of time.  It supports symmetric ciphers in the ECB, CBC, CBCNOPAD, CFB, OFB, CTR, and GCM modes of operation.  Unlike the multi-part API, a single long-running request is used, where the request and response bodies are streamed simultaneously.  <br>\nBoth the request and response are a sequence of frames, each encoded in CBOR.  The frames are concatenated into a CBOR sequence, following RFC 8742.  The request consists of an \"init\" frame, zero or more \"ad\" frames, one or more \"cipher\" frames, and a \"final\" frame.  A successful response consists of an \"init\" frame, one or more \"plain\" frames, and a \"final\" frame.  <br>\nIf an error occurs processing the \"init\" frame, the error is indicated as an HTTP status code and plain-text body, like all other APIs.  If an error occurs later, it is reported as an \"error\" frame, and no further frames are sent.\n",
           "operationId":"streamDecrypt",
           "requestBody":{
              "$ref":"#/components/requestBodies/StreamDecryptRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/StreamDecryptResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/sign":{
        "post":{
           "tags":[
              "Sign and Verify"
           ],
           "summary":"Sign with a private key",
           "description":"Sign data with a private key. The signing key must be an asymmetric key with the private part present. The sign operation must be enabled for this key. Symmetric keys may not be used to sign data. They can be used with the computeMac and verifyMac methods. <br>\nThe data must be hashed with a SHA-1 or SHA-2 family hash algorithm.\n",
           "operationId":"sign",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/SignRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/SignResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/sign":{
        "post":{
           "tags":[
              "Sign and Verify"
           ],
           "summary":"Sign with a private key",
           "description":"Sign data with a private key. The signing key must be an asymmetric key with the private part present. The sign operation must be enabled for this key. Symmetric keys may not be used to sign data. They can be used with the computeMac and verifyMac methods. <br>\nThe data must be hashed with a SHA-1 or SHA-2 family hash algorithm.\n",
           "operationId":"signEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/SignRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/SignResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/batch/sign":{
        "post":{
           "tags":[
              "Sign and Verify"
           ],
           "summary":"Batch sign with one or more private keys",
           "description":"The data to be signed and the key ids to be used are provided in the request body. The signature is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB.\n",
           "operationId":"batchSign",
           "requestBody":{
              "$ref":"#/components/requestBodies/BatchSignRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/BatchSignResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/verify":{
        "post":{
           "tags":[
              "Sign and Verify"
           ],
           "summary":"Verify a signature with a key",
           "description":"Verify a signature with a public key. The verifying key must be an asymmetric key with the verify operation enabled. Symmetric keys may not be used to verify data. They can be used with the computeMac and verifyMac operations. <br>\nThe signature must have been created with a SHA-1 or SHA-2 family hash algorithm.\n",
           "operationId":"verify",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/VerifyRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/VerifyResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/verify":{
        "post":{
           "tags":[
              "Sign and Verify"
           ],
           "summary":"Verify a signature with a key",
           "description":"Verify a signature with a public key. The verifying key must be an asymmetric key with the verify operation enabled. Symmetric keys may not be used to verify data. They can be used with the computeMac and verifyMac operations. <br>\nThe signature must have been created with a SHA-1 or SHA-2 family hash algorithm.\n",
           "operationId":"verifyEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/VerifyRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/VerifyResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/batch/verify":{
        "post":{
           "tags":[
              "Sign and Verify"
           ],
           "summary":"Batch verify with one or more private keys",
           "description":"The signature to be verified and the key ids to be used are provided in the request body. The result (true of false) returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB.\n",
           "operationId":"batchVerify",
           "requestBody":{
              "$ref":"#/components/requestBodies/BatchVerifyRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/BatchVerifyResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/digest":{
        "post":{
           "tags":[
              "Digest"
           ],
           "summary":"Compute a message digest of data",
           "description":"This returns the digest of data provided in request body using the algorithm specified in request body. Maximum size of request body supported is 512KB.\n",
           "operationId":"computeDigest",
           "requestBody":{
              "$ref":"#/components/requestBodies/DigestRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/DigestResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/mac":{
        "post":{
           "tags":[
              "Digest"
           ],
           "summary":"Compute MAC using a key",
           "description":"Compute a cryptographic Message Authentication Code on a message using a symmetric key. The key must have the MACGenerate operation enabled. Asymmetric keys may not be used to generate MACs. They can be used with the sign and verify operations.\n",
           "operationId":"computeMac",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/MacGenerateRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/MacGenerateResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/mac":{
        "post":{
           "tags":[
              "Digest"
           ],
           "summary":"Compute MAC using a key",
           "description":"Compute a cryptographic Message Authentication Code on a message using a symmetric key. The key must have the MACGenerate operation enabled. Asymmetric keys may not be used to generate MACs. They can be used with the sign and verify operations.\n",
           "operationId":"computeMacEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/MacGenerateRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/MacGenerateResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/batch/mac":{
        "post":{
           "tags":[
              "Digest"
           ],
           "summary":"Batch MAC with one or more keys",
           "description":"Message to compute a cryptographic Message Authentication Code and the key ids to be used are provided in the request body. The MAC is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB.\n",
           "operationId":"batchMac",
           "requestBody":{
              "$ref":"#/components/requestBodies/BatchMacRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/BatchMacResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/macverify":{
        "post":{
           "tags":[
              "Digest"
           ],
           "summary":"Verify MAC using a key",
           "description":"The data to be MACed, the algorithm, and a pre-computed MAC are provided in the request body, and the key id is provided in the URL. DSM computes the MAC of the data and compares it with the specified MAC, and returns the outcome of the MAC verification in the response body. Maximum size of request body supported is 512KB. Supported digest algorithms are - SHA1, SHA256, SHA384, and SHA512.\n",
           "operationId":"verifyMac",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/MacVerifyRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/MacVerifyResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/macverify":{
        "post":{
           "tags":[
              "Digest"
           ],
           "summary":"Verify MAC using a key",
           "description":"The data to be MACed, the algorithm, and a pre-computed MAC are provided in the request body, and the key id is provided in the URL. DSM computes the MAC of the data and compares it with the specified MAC, and returns the outcome of the MAC verification in the response body. Maximum size of request body supported is 512KB. Supported digest algorithms are - SHA1, SHA256, SHA384, and SHA512.\n",
           "operationId":"verifyMacEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/MacVerifyRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/MacVerifyResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/batch/macverify":{
        "post":{
           "tags":[
              "Digest"
           ],
           "summary":"Batch MAC Verify with one or more keys",
           "description":"The data to be MACed, the algorithm, a pre-computed MAC are provided in the request body, and the key id to be used are provided in the request body. The MAC is returned in the response body. The ordering of the body matches the ordering of the request. An individual status code is returned for each batch item. Maximum size of the entire batch request is 512 KB.\n",
           "operationId":"batchMacVerify",
           "requestBody":{
              "$ref":"#/components/requestBodies/BatchMacVerifyRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/BatchVerifyResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/derive":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Derive a key from another key",
           "description":"This derives a key from an existing key and returns the properties of the new key. The request body contains the requested properties for the new as well as the mechanism to be used to produce the key material for the new key.\n",
           "operationId":"deriveKey",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/DeriveKeyRequest"
           },
           "responses":{
              "201":{
                 "description":"A newly created security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/derive":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Derive a key from another key",
           "description":"This derives a key from an existing key and returns the properties of the new key. The request body contains the requested properties for the new as well as the mechanism to be used to produce the key material for the new key.\n",
           "operationId":"deriveKeyEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/DeriveKeyRequestEx"
           },
           "responses":{
              "201":{
                 "description":"A newly created security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/agree":{
        "post":{
           "tags":[
              "Security Objects"
           ],
           "summary":"Agree on a key from two other keys",
           "description":"This does a cryptographic key agreement operation between a public and private key. Both keys must have been generated from the same parameters (e.g. the same elliptic curve). Both keys must allow the AGREEKEY operation. The request body contains the requested properties for the new key as well as the mechanism (e.g. Diffie-Hellman) to be used to produce the key material for the new key.\nThe output of this API should not be used directly as a cryptographic key. The target object type should be HMAC or Secret, and a key derivation procedure should be used to derive the actual key material.\n",
           "operationId":"agreeKey",
           "requestBody":{
              "$ref":"#/components/requestBodies/AgreeKeyRequest"
           },
           "responses":{
              "201":{
                 "description":"A newly created security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/wrapkey":{
        "post":{
           "tags":[
              "Wrapping and Unwrapping"
           ],
           "summary":"Wrap a security object with a key\n",
           "description":"Wrap (encrypt) an existing security object with a key. This allows keys to be securely exported from DSM so they can be later imported into DSM or another key management system. <br>\nThe key-id parameter in the URL specifies the key that will be used to wrap the other security object. The security object being wrapped is specified inside of the request body. <br>\nThe alg and mode parameters specify the encryption algorithm and cipher mode being used for the wrapping key. The algorithm of the key being wrapped is not provided to this API call. <br>\nThe key being wrapped must have the export operation enabled. The wrapping key must have the wrapkey operation enabled. <br>\nThe following wrapping operations are supported:\n  * Symmetric keys, HMAC keys, opaque objects, and secret objects may be wrapped with symmetric or asymmetric keys.\n  * Asymmetric keys may be wrapped with symmetric keys. Wrapping an asymmetric key with an asymmetric key is not supported.\n\nWhen wrapping with an asymmetric key, the wrapped object size must fit as plaintext for the wrapping key size and algorithm.\n",
           "operationId":"wrapKey",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/WrapKeyRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/WrapKeyResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/wrapkey":{
        "post":{
           "tags":[
              "Wrapping and Unwrapping"
           ],
           "summary":"Wrap a security object with a key\n",
           "description":"Wrap (encrypt) an existing security object with a key. This allows keys to be securely exported from DSM so they can be later imported into DSM or another key management system. <br>\nThe key-id parameter in the URL specifies the key that will be used to wrap the other security object. The security object being wrapped is specified inside of the request body. <br>\nThe alg and mode parameters specify the encryption algorithm and cipher mode being used for the wrapping key. The algorithm of the key being wrapped is not provided to this API call. <br>\nThe key being wrapped must have the export operation enabled. The wrapping key must have the wrapkey operation enabled. <br>\nThe following wrapping operations are supported:\n  * Symmetric keys, HMAC keys, opaque objects, and secret objects may be wrapped with symmetric or asymmetric keys.\n  * Asymmetric keys may be wrapped with symmetric keys. Wrapping an asymmetric key with an asymmetric key is not supported.\n\nWhen wrapping with an asymmetric key, the wrapped object size must fit as plaintext for the wrapping key size and algorithm.\n",
           "operationId":"wrapKeyEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/WrapKeyRequestEx"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/WrapKeyResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/unwrapkey":{
        "post":{
           "tags":[
              "Wrapping and Unwrapping"
           ],
           "summary":"Unwrap a security object with a key",
           "description":"Unwrap (decrypt) a wrapped key and import it into DSM. This allows securely importing into DSM security objects that were previously wrapped by DSM or another key management system. A new security object will be created in DSM with the unwrapped data. <br>\nThe key-id parameter in the URL specifies the key that will be used to unwrap the other security object. This key must have the unwrapkey operation enabled. <br>\nThe alg and mode parameters specify the encryption algorithm and cipher mode being used by the unwrapping key. The obj_type parameter specifies the object type of the security object being unwrapped. The size or elliptic curve of the object being unwrapped does not need to be specified.\n",
           "operationId":"unwrapKey",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/UnwrapKeyRequest"
           },
           "responses":{
              "201":{
                 "description":"A newly created security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/unwrapkey":{
        "post":{
           "tags":[
              "Wrapping and Unwrapping"
           ],
           "summary":"Unwrap a security object with a key",
           "description":"Unwrap (decrypt) a wrapped key and import it into DSM. This allows securely importing into DSM security objects that were previously wrapped by DSM or another key management system. A new security object will be created in DSM with the unwrapped data. <br>\nThe key-id parameter in the URL specifies the key that will be used to unwrap the other security object. This key must have the unwrapkey operation enabled. <br>\nThe alg and mode parameters specify the encryption algorithm and cipher mode being used by the unwrapping key. The obj_type parameter specifies the object type of the security object being unwrapped. The size or elliptic curve of the object being unwrapped does not need to be specified.\n",
           "operationId":"unwrapKeyEx",
           "requestBody":{
              "$ref":"#/components/requestBodies/UnwrapKeyRequestEx"
           },
           "responses":{
              "201":{
                 "description":"A newly created security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/restore":{
        "post":{
           "tags":[
              "AWS"
           ],
           "summary":"Restore an AWS KMS key from its source key material",
           "description":"Restore an AWS key from its source key material",
           "operationId":"restore",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "responses":{
              "200":{
                 "description":"The restored security object.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/schedule_deletion":{
        "post":{
           "tags":[
              "AWS"
           ],
           "summary":"Schedule an AWS KMS key for deletion",
           "description":"Schedule an AWS KMS key for deletion",
           "operationId":"scheduleDeletion",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/ScheduleDeletionRequest"
           },
           "responses":{
              "200":{
                 "description":"The security object scheduled for deletion.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/cancel_deletion":{
        "post":{
           "tags":[
              "AWS"
           ],
           "summary":"Cancel scheduled deletion of an AWS KMS key",
           "description":"Cancel scheduled deletion of an AWS KMS key",
           "operationId":"cancelDeletion",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "responses":{
              "200":{
                 "description":"The security object for which deletion was cancelled.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/crypto/v1/keys/{key-id}/delete_key_material":{
        "post":{
           "tags":[
              "AWS"
           ],
           "summary":"Delete the key material of an AWS KMS key",
           "description":"Delete the key material of an AWS KMS key",
           "operationId":"deleteKeyMaterial",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              }
           ],
           "responses":{
              "200":{
                 "description":"The security object for which the key material was deleted.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/KeyObject"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/apps":{
        "get":{
           "tags":[
              "Apps"
           ],
           "summary":"Get all applications",
           "description":"Get details of all applications the current user has access to.",
           "operationId":"getApps",
           "parameters":[
              {
                 "name":"group_id",
                 "in":"query",
                 "description":"Only retrieve applications in the specified group.",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"sort",
                 "in":"query",
                 "description":"This specifies the property (`app_id` only, for now) and order (ascending or descending) with which to sort the apps. By default, apps are sorted by `app_id` in ascending order. The syntax is \"<property>:[asc|desc]\" (e.g. \"app_id:desc\") or just \"<property>\" (ascending order by default).\n",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"start",
                 "in":"query",
                 "description":"If provided, this must be a value of the property specified in `sort`. Returned apps will begin just above or just below this value (for asc/desc order resp.).\n",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"limit",
                 "in":"query",
                 "description":"Maximum number of apps to return. If not provided, the limit is 100.",
                 "schema":{
                    "type":"integer"
                 }
              },
              {
                 "name":"offset",
                 "in":"query",
                 "description":"Number of apps past `start` to skip.",
                 "schema":{
                    "type":"integer"
                 }
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AppListResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "post":{
           "tags":[
              "Apps"
           ],
           "summary":"Create a new application",
           "description":"Create a new application with the specified properties.",
           "operationId":"createApp",
           "requestBody":{
              "$ref":"#/components/requestBodies/AppRequest"
           },
           "responses":{
              "201":{
                 "$ref":"#/components/responses/AppResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/apps/{app-id}":{
        "get":{
           "tags":[
              "Apps"
           ],
           "summary":"Get a specific application",
           "description":"Look up an application by application ID.",
           "operationId":"getApp",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AppId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AppResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "delete":{
           "tags":[
              "Apps"
           ],
           "summary":"Delete application",
           "description":"Remove an application from DSM.",
           "operationId":"deleteApp",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AppId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "patch":{
           "tags":[
              "Apps"
           ],
           "summary":"Update an application",
           "description":"Change an application's properties, such as name, description, or group membership.",
           "operationId":"updateApp",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AppId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/AppRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AppResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/apps/{app-id}/reset_secret":{
        "post":{
           "tags":[
              "Apps"
           ],
           "summary":"Regenerate API key",
           "description":"Create a new API key for an application. An application may only have one valid API key at a time, so performing this action will invalidate all old API keys. This does not invalidate existing sessions, so any applications with an existing open session will be able to continue operating with their old session until those sessions expire.\n",
           "operationId":"regenerateApiKey",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AppId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/AppResetSecretRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AppResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/apps/{app-id}/credential":{
        "get":{
           "tags":[
              "Apps"
           ],
           "summary":"Get a specific application's credential",
           "description":"Retrieve the authentication credential (API key or certificate) for a particular application. Only users who are an administrator of at least one of the application's groups can retrieve the credential.",
           "operationId":"getCredential",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AppId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AppCredentialResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/groups":{
        "get":{
           "tags":[
              "Groups"
           ],
           "summary":"Get all groups",
           "description":"Get detailed information about all groups the authenticated User or authenticated Application belongs to.",
           "operationId":"getGroups",
           "responses":{
              "200":{
                 "$ref":"#/components/responses/GroupListResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "post":{
           "tags":[
              "Groups"
           ],
           "summary":"Create new group",
           "description":"Create a new group with the specified properties.",
           "operationId":"createGroup",
           "requestBody":{
              "$ref":"#/components/requestBodies/GroupRequest"
           },
           "responses":{
              "201":{
                 "$ref":"#/components/responses/GroupResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/groups/{group-id}":{
        "get":{
           "tags":[
              "Groups"
           ],
           "summary":"Get a specific group",
           "description":"Look up a specific group by group ID.",
           "operationId":"getGroup",
           "parameters":[
              {
                 "$ref":"#/components/parameters/GroupId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/GroupResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "delete":{
           "tags":[
              "Groups"
           ],
           "summary":"Delete group",
           "description":"Remove a group from DSM.",
           "operationId":"deleteGroup",
           "parameters":[
              {
                 "$ref":"#/components/parameters/GroupId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "patch":{
           "tags":[
              "Groups"
           ],
           "summary":"Update group",
           "description":"Change a group's properties.",
           "operationId":"updateGroup",
           "parameters":[
              {
                 "$ref":"#/components/parameters/GroupId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/GroupRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/GroupResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/groups/hmg/check":{
        "post":{
           "tags":[
              "Groups"
           ],
           "summary":"Check a HMG configuration",
           "description":"Check that the HMG configuration provided is valid and reachable.",
           "operationId":"checkHmg",
           "requestBody":{
              "$ref":"#/components/requestBodies/HmgCheckRequest"
           },
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/groups/{group-id}/hmg/check":{
        "post":{
           "tags":[
              "Groups"
           ],
           "summary":"Check the HMG configuration of a group",
           "description":"Check that the HMG configuration for a particular group is valid and reachable.",
           "operationId":"checkGroupHmg",
           "parameters":[
              {
                 "$ref":"#/components/parameters/GroupId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/groups/{group-id}/hmg/scan":{
        "post":{
           "tags":[
              "Groups"
           ],
           "summary":"Scan all keys from the external source for a particular group",
           "description":"For a group backed by an external source, scan the external source for changes since the last scan, and accordingly update the group. This includes creating virtual keys for new keys found, marking the virtual keys of missing keys as destroyed, and updating the metadata of changed keys.\n",
           "operationId":"scanHmg",
           "parameters":[
              {
                 "$ref":"#/components/parameters/GroupId"
              }
           ],
           "responses":{
              "200":{
                 "description":"An array of newly created security objects.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "type":"array",
                          "items":{
                             "$ref":"#/components/schemas/KeyObject"
                          }
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/groups/hmg/azure_vaults":{
        "post":{
           "tags":[
              "Groups"
           ],
           "summary":"List all Azure Key Vaults available to back a group",
           "description":"Given an Azure HMG configuration, fetch a list of available Azure key vaults which can be used to back a group.\n",
           "operationId":"azureVaults",
           "responses":{
              "200":{
                 "description":"An array of viable Azure key vaults.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "type":"array",
                          "items":{
                             "$ref":"#/components/schemas/AzureKeyVaultResponse"
                          }
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/accounts":{
        "get":{
           "tags":[
              "Accounts"
           ],
           "summary":"Get all accounts",
           "description":"Get detailed information on all accounts the current user has access to.",
           "operationId":"getAccounts",
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AccountListResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "post":{
           "tags":[
              "Accounts"
           ],
           "summary":"Create a new account",
           "description":"Create a new account with the specified properties.",
           "operationId":"createAccount",
           "requestBody":{
              "$ref":"#/components/requestBodies/AccountRequest"
           },
           "responses":{
              "201":{
                 "$ref":"#/components/responses/AccountResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/accounts/{account-id}":{
        "get":{
           "tags":[
              "Accounts"
           ],
           "summary":"Get a specific account",
           "description":"Look up an account by account ID.",
           "operationId":"getAccount",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AccountId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AccountResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "delete":{
           "tags":[
              "Accounts"
           ],
           "summary":"Delete account",
           "description":"Remove an account from DSM.",
           "operationId":"deleteAccount",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AccountId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "patch":{
           "tags":[
              "Accounts"
           ],
           "summary":"Update account",
           "description":"Update the properties of an account. Only certain properties may be changed with this API.\n",
           "operationId":"updateAccount",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AccountId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/AccountRequest"
           },
           "responses":{
              "200":{
                 "description":"Updated account",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/Account"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/accounts/child":{
        "post":{
           "tags":[
              "Child Accounts"
           ],
           "summary":"Create a new child account",
           "description":"Create a new child account with the specified properties.",
           "operationId":"createChildAccount",
           "requestBody":{
              "$ref":"#/components/requestBodies/AccountRequest"
           },
           "responses":{
              "201":{
                 "$ref":"#/components/responses/AccountResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/accounts/{account-id}/child":{
        "get":{
           "tags":[
              "Child Accounts"
           ],
           "summary":"Get all child accounts of the given account",
           "description":"Get all child accounts of the given account.",
           "operationId":"getChildAccounts",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AccountId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AccountListResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users":{
        "get":{
           "tags":[
              "Users"
           ],
           "summary":"Get all users",
           "operationId":"getUsers",
           "parameters":[
              {
                 "name":"group_id",
                 "in":"query",
                 "description":"Only retrieve users in the specified group.",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"sort",
                 "in":"query",
                 "description":"This specifies the property (`user_id` only, for now) and order (ascending or descending) with which to sort the users. By default, users are sorted by `user_id` in ascending order. The syntax is \"<property>:[asc|desc]\" (e.g. \"user_id:desc\") or just \"<property>\" (ascending order by default).\n",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"start",
                 "in":"query",
                 "description":"If provided, this must be a value of the property specified in `sort`. Returned users will begin just above or just below this value (for asc/desc order resp.).\n",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"limit",
                 "in":"query",
                 "description":"Maximum number of users to return. If not provided, the limit is 100.",
                 "schema":{
                    "type":"integer"
                 }
              },
              {
                 "name":"offset",
                 "in":"query",
                 "description":"Number of users past `start` to skip.",
                 "schema":{
                    "type":"integer"
                 }
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/UserListResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Create a new user",
           "description":"Signs up a new user.",
           "operationId":"createUser",
           "requestBody":{
              "$ref":"#/components/requestBodies/SignupRequest"
           },
           "responses":{
              "201":{
                 "$ref":"#/components/responses/UserResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "delete":{
           "tags":[
              "Users"
           ],
           "summary":"Completely delete a user profile from system",
           "description":"Completely deletes the currently logged in user from the system.",
           "operationId":"deleteUserAccount",
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/invite":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Invite a user",
           "description":"Invite an existing user or new user to join an existing account. Only user email is required for invite API\n",
           "operationId":"inviteUser",
           "requestBody":{
              "$ref":"#/components/requestBodies/UserRequest"
           },
           "responses":{
              "201":{
                 "$ref":"#/components/responses/UserResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/{user-id}":{
        "get":{
           "tags":[
              "Users"
           ],
           "summary":"Get a specific user",
           "operationId":"getUser",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/UserResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "patch":{
           "tags":[
              "Users"
           ],
           "summary":"Update user",
           "description":"Change a user's properties.",
           "operationId":"updateUser",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/UserRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/UserResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/change_password":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Change user password",
           "operationId":"changePassword",
           "requestBody":{
              "$ref":"#/components/requestBodies/PasswordChangeRequest"
           },
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/accounts":{
        "get":{
           "tags":[
              "Users"
           ],
           "summary":"Get account information for the user",
           "description":"Obtain the current user's account information.",
           "operationId":"getUserAccount",
           "responses":{
              "200":{
                 "$ref":"#/components/responses/UserAccountResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/forgot_password":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Initiate password reset sequence for a user",
           "operationId":"forgotPassword",
           "requestBody":{
              "$ref":"#/components/requestBodies/ForgotPasswordRequest"
           },
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/{user-id}/reset_password":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Reset a user's password",
           "description":"Resetting a user's password. User must have a valid reset token from forgot password step.",
           "operationId":"resetPassword",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/PasswordResetRequest"
           },
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/process_invite":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Process a user's pending account invitations",
           "description":"Process a user's pending invitations. It does both accepts and rejects.",
           "operationId":"processInvitations",
           "requestBody":{
              "$ref":"#/components/requestBodies/ProcessInviteRequest"
           },
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/{user-id}/resend_invite":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Resend invite to the user to join a specific account",
           "operationId":"resendInvitation",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/{user-id}/accounts":{
        "delete":{
           "tags":[
              "Users"
           ],
           "summary":"Removed user's association with an account",
           "operationId":"deleteUser",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/{user-id}/validate_token":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Validates password reset token for the user",
           "operationId":"validatePasswordResetToken",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/ValidateTokenRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/ValidateTokenResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/{user-id}/confirm_email":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Confirms user's email address",
           "operationId":"confirmEmail",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/ConfirmEmailRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/ConfirmEmailResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/{user-id}/resend_confirm_email":{
        "post":{
           "tags":[
              "Users"
           ],
           "summary":"Resend email with link to confirm user's email address",
           "operationId":"resendConfirmEmail",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/child_account":{
        "post":{
           "tags":[
              "Child Account Users"
           ],
           "summary":"Create a new user user in a child account",
           "description":"Create a new user user in a child account.",
           "operationId":"createChildAccountUser",
           "requestBody":{
              "$ref":"#/components/requestBodies/ChildAccountUserRequest"
           },
           "responses":{
              "201":{
                 "$ref":"#/components/responses/ChildAccountUserResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/child_account/{user-id}":{
        "get":{
           "tags":[
              "Child Account Users"
           ],
           "summary":"Get a specific child account user",
           "operationId":"getChildAccountUser",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/ChildAccountUserResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "delete":{
           "tags":[
              "Child Account Users"
           ],
           "summary":"Completely delete a user in child account",
           "description":"Completely delete a user in child account.",
           "operationId":"deleteChildAccountUser",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "patch":{
           "tags":[
              "Child Account Users"
           ],
           "summary":"Update a child account user",
           "description":"Change a child account user's properties.",
           "operationId":"updateChildAccountUser",
           "parameters":[
              {
                 "$ref":"#/components/parameters/UserId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/ChildAccountUserRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/ChildAccountUserResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/child_account/{account-id}/all":{
        "get":{
           "tags":[
              "Child Account Users"
           ],
           "summary":"Get all users in a child account",
           "description":"Get all users in a child account",
           "operationId":"getAllChildAccountUsers",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AccountId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/ChildAccountUserListResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/logs":{
        "get":{
           "tags":[
              "Logs"
           ],
           "summary":"Get audit logs",
           "description":"Get audit log entries matching the requested filters.",
           "operationId":"getAuditLogs",
           "parameters":[
              {
                 "$ref":"#/components/parameters/Size"
              },
              {
                 "$ref":"#/components/parameters/From"
              },
              {
                 "$ref":"#/components/parameters/ActionType"
              },
              {
                 "$ref":"#/components/parameters/ActorType"
              },
              {
                 "$ref":"#/components/parameters/ActorId"
              },
              {
                 "$ref":"#/components/parameters/ObjectId"
              },
              {
                 "$ref":"#/components/parameters/Severity"
              },
              {
                 "$ref":"#/components/parameters/RangeFrom"
              },
              {
                 "$ref":"#/components/parameters/RangeTo"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AuditLogResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/stats/groups":{
        "get":{
           "tags":[
              "Stats"
           ],
           "summary":"Get group aggregate transaction statistics",
           "description":"This is for obtaining group level aggregate transaction statistics to find top groups by transaction. API supports query parameters for fetchings stats for specific time period, for maximum top count and with number of data points desired.",
           "operationId":"getGroupsStats",
           "parameters":[
              {
                 "$ref":"#/components/parameters/RangeFrom"
              },
              {
                 "$ref":"#/components/parameters/RangeTo"
              },
              {
                 "$ref":"#/components/parameters/TopCount"
              },
              {
                 "$ref":"#/components/parameters/NumPoints"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/StatsResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/stats/apps":{
        "get":{
           "tags":[
              "Stats"
           ],
           "summary":"Get app aggregate transaction statistics",
           "description":"This is for obtaining app level aggregate transaction statistics to find top apps by transaction. API supports query parameters for fetchings stats for specific time period, for maximum top count and with number of data points desired.",
           "operationId":"getAppsStats",
           "parameters":[
              {
                 "$ref":"#/components/parameters/RangeFrom"
              },
              {
                 "$ref":"#/components/parameters/RangeTo"
              },
              {
                 "$ref":"#/components/parameters/TopCount"
              },
              {
                 "$ref":"#/components/parameters/NumPoints"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/StatsResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/stats/{app-id}/app":{
        "get":{
           "tags":[
              "Stats"
           ],
           "summary":"Get transaction statistics for a specific application",
           "description":"This API is for obtaining transaction statistics for a specific application. API supports query parameters for fetchings stats for specific time period and with number of data points desired.",
           "operationId":"getAppStats",
           "parameters":[
              {
                 "$ref":"#/components/parameters/AppId"
              },
              {
                 "$ref":"#/components/parameters/RangeFrom"
              },
              {
                 "$ref":"#/components/parameters/RangeTo"
              },
              {
                 "$ref":"#/components/parameters/NumPoints"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/StatsResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/stats/{group-id}/group":{
        "get":{
           "tags":[
              "Stats"
           ],
           "summary":"Get transaction statistics for a specific group",
           "description":"This API is for obtaining transaction statistics for a specific group. API supports query parameters for fetchings stats for specific time period and with number of data points desired.",
           "operationId":"getGroupStats",
           "parameters":[
              {
                 "$ref":"#/components/parameters/GroupId"
              },
              {
                 "$ref":"#/components/parameters/RangeFrom"
              },
              {
                 "$ref":"#/components/parameters/RangeTo"
              },
              {
                 "$ref":"#/components/parameters/NumPoints"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/StatsResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/stats/{key-id}/key":{
        "get":{
           "tags":[
              "Stats"
           ],
           "summary":"Get transaction statistics for a specific security object",
           "description":"This API is for obtaining transaction statistics for a specific security object. API supports query parameters for fetchings stats for specific time period and with number of data points desired.",
           "operationId":"getSecurityObjectStats",
           "parameters":[
              {
                 "$ref":"#/components/parameters/KeyId"
              },
              {
                 "$ref":"#/components/parameters/RangeFrom"
              },
              {
                 "$ref":"#/components/parameters/RangeTo"
              },
              {
                 "$ref":"#/components/parameters/NumPoints"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/StatsResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/auth/2fa/u2f":{
        "post":{
           "tags":[
              "Two factor authentication"
           ],
           "summary":"Use a U2F key to complete authentication",
           "description":"Complete two factor authentication with a U2F authentication token to authenticate to DSM. The response body contains a bearer authentication token which needs to be provided by subsequent calls for the duration of the session.\n",
           "operationId":"authorizeU2F",
           "responses":{
              "204":{
                 "description":"Nothing is returned on success",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "basicAuth":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/auth/2fa/recovery_code":{
        "post":{
           "tags":[
              "Two factor authentication"
           ],
           "summary":"Use a backup recovery code to complete authentication",
           "description":"Complete two factor authentication with a backup recovery code. The caller needs to provide a bearer token for the session in the request body. Each recovery code may only be used once, so users should update their two factor configuration after using this API.\n",
           "operationId":"authorizeRecoveryCode",
           "responses":{
              "204":{
                 "description":"Nothing is returned on success",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/config_2fa/auth":{
        "post":{
           "tags":[
              "Authentication"
           ],
           "summary":"Unlock two factor configuration",
           "description":"Re-authenticate to unlock two factor configuration. Two factor configuration must be unlocked to enable or disable two factor authentication, add or remove two factor devices, or regenerate recovery codes. The caller needs to provide a bearer token for the session in the request body.\n",
           "operationId":"unlock2F",
           "responses":{
              "204":{
                 "description":"Nothing is returned on success",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/config_2fa/new_challenge":{
        "post":{
           "tags":[
              "Two factor authentication"
           ],
           "summary":"Generate a new challenge for registering a U2F devices",
           "description":"Generate a new challenge that may be used to register U2F devices. The caller needs to provide a bearer token for the session in the request body.\n",
           "operationId":"generateU2FChallenge",
           "responses":{
              "200":{
                 "$ref":"#/components/responses/MfaChallenge"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/session/config_2fa/terminate":{
        "post":{
           "tags":[
              "Two factor authentication"
           ],
           "summary":"Lock two factor configuration",
           "description":"Lock two factor configuration after completing two factor reconfiguration. The caller needs to provide a bearer token for the session in the request body. If this API is not called, two factor configuration will be locked automatically after ten minutes.\n",
           "operationId":"lock2F",
           "responses":{
              "204":{
                 "description":"Nothing is returned on success",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/users/generate_recovery_code":{
        "post":{
           "tags":[
              "Two factor authentication"
           ],
           "summary":"Generate backup recovery codes for the current user",
           "description":"Generate backup recovery codes that may be used to complete complete two factor authentication. The caller needs to provide a bearer token for the session in the request body. Two factor configuration must be unlocked to use this API.\n",
           "operationId":"generateRecoveryCodes",
           "responses":{
              "200":{
                 "$ref":"#/components/responses/RecoveryCodes"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/plugins":{
        "get":{
           "tags":[
              "Plugins"
           ],
           "summary":"Get all plugins",
           "description":"Get details of all plugins the current user has access to.",
           "operationId":"getPlugins",
           "parameters":[
              {
                 "name":"group_id",
                 "in":"query",
                 "description":"Only retrieve plugins in the specified group.",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"sort",
                 "in":"query",
                 "description":"This specifies the property (`plugin_id` only, for now) and order (ascending or descending) with which to sort the apps. By default, plugins are sorted by `plugin_id` in ascending order. The syntax is \"<property>:[asc|desc]\" (e.g. \"plugin_id:desc\") or just \"<property>\" (ascending order by default).\n",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"start",
                 "in":"query",
                 "description":"If provided, this must be a value of the property specified in `sort`. Returned apps will begin just above or just below this value (for asc/desc order resp.).\n",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"limit",
                 "in":"query",
                 "description":"Maximum number of apps to return. If not provided, the limit is 100.",
                 "schema":{
                    "type":"integer"
                 }
              },
              {
                 "name":"offset",
                 "in":"query",
                 "description":"Number of apps past `start` to skip.",
                 "schema":{
                    "type":"integer"
                 }
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/PluginListResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "post":{
           "tags":[
              "Plugins"
           ],
           "summary":"Create a new plugin",
           "description":"Create a new plugin with the specified properties.",
           "operationId":"createPlugin",
           "requestBody":{
              "$ref":"#/components/requestBodies/PluginRequest"
           },
           "responses":{
              "201":{
                 "$ref":"#/components/responses/PluginResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/plugins/{plugin-id}":{
        "get":{
           "tags":[
              "Plugins"
           ],
           "summary":"Get a specific plugin",
           "description":"Look up plugin by plugin ID.",
           "operationId":"getPlugin",
           "parameters":[
              {
                 "$ref":"#/components/parameters/PluginId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/PluginResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "post":{
           "tags":[
              "Plugins"
           ],
           "summary":"Invoke a plugin",
           "description":"Invokes a plugin execution with the provided request body as input to the plugin.",
           "operationId":"invokePlugin",
           "parameters":[
              {
                 "$ref":"#/components/parameters/PluginId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/PluginInvokeRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/PluginInvokeResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "delete":{
           "tags":[
              "Plugins"
           ],
           "summary":"Delete plugin",
           "description":"Remove a plugin from DSM.",
           "operationId":"deletePlugin",
           "parameters":[
              {
                 "$ref":"#/components/parameters/PluginId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "patch":{
           "tags":[
              "Plugins"
           ],
           "summary":"Update a plugin",
           "description":"Change a plugin's properties, such as name, description, code, or group membership.",
           "operationId":"updatePlugin",
           "parameters":[
              {
                 "$ref":"#/components/parameters/PluginId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/PluginRequest"
           },
           "responses":{
              "200":{
                 "$ref":"#/components/responses/AppResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/plugins/invoke/{plugin-id}":{
        "get":{
           "tags":[
              "Plugins"
           ],
           "summary":"Invoke a plugin using GET.",
           "description":"Invokes a plugin with empty input.",
           "operationId": "invokePlugin",
           "parameters":[
              {
                 "$ref":"#/components/parameters/PluginId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/PluginInvokeResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/approval_requests":{
        "get":{
           "tags":[
              "Approval Requests"
           ],
           "summary":"Get all approval requests",
           "operationId":"getApprovalRequests",
           "parameters":[
              {
                 "name":"requester",
                 "in":"query",
                 "description":"Only retrieve approval requests with the specified requester ID",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"reviewer",
                 "in":"query",
                 "description":"Only retrieve approval requests with the specified reviewer ID",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"subject",
                 "in":"query",
                 "description":"Only retrieve approval requests with the specified subject ID",
                 "schema":{
                    "type":"string"
                 }
              },
              {
                 "name":"status",
                 "in":"query",
                 "description":"Only retrieve approval requests with the specified approval status",
                 "schema":{
                    "type":"string",
                    "enum":[
                       "PENDING",
                       "APPROVED",
                       "DENIED",
                       "FAILED"
                    ]
                 }
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/ApprovalRequestListResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "post":{
           "tags":[
              "Approval Requests"
           ],
           "summary":"Create approval request",
           "operationId":"createApprovalRequest",
           "requestBody":{
              "$ref":"#/components/requestBodies/ApprovalRequestRequest"
           },
           "responses":{
              "201":{
                 "description":"A newly created approval request.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/ApprovalRequest"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/approval_requests/{request-id}":{
        "get":{
           "tags":[
              "Approval Requests"
           ],
           "summary":"Get an approval request.",
           "description":"Get the details and status of a particular approval request.",
           "operationId":"getApprovalRequest",
           "parameters":[
              {
                 "$ref":"#/components/parameters/RequestId"
              }
           ],
           "responses":{
              "200":{
                 "description":"Details about the specified approval request.",
                 "content":{
                    "application/json":{
                       "schema":{
                          "$ref":"#/components/schemas/ApprovalRequest"
                       }
                    }
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        },
        "delete":{
           "tags":[
              "Approval Requests"
           ],
           "summary":"Delete an approval request.",
           "operationId":"deleteApprovalRequest",
           "parameters":[
              {
                 "$ref":"#/components/parameters/RequestId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/approval_requests/{request-id}/approve":{
        "post":{
           "tags":[
              "Approval Requests"
           ],
           "summary":"Approve a request.",
           "operationId":"approve",
           "parameters":[
              {
                 "$ref":"#/components/parameters/RequestId"
              }
           ],
           "requestBody":{
              "$ref":"#/components/requestBodies/ApproveRequest"
           },
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/approval_requests/{request-id}/deny":{
        "post":{
           "tags":[
              "Approval Requests"
           ],
           "summary":"Deny a request.",
           "operationId":"deny",
           "parameters":[
              {
                 "$ref":"#/components/parameters/RequestId"
              }
           ],
           "responses":{
              "204":{
                 "description":"Nothing is returned on success.",
                 "content":{
                    
                 }
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     },
     "/sys/v1/approval_requests/{request-id}/result":{
        "post":{
           "tags":[
              "Approval Requests"
           ],
           "summary":"Get the result for an approved or failed request.",
           "operationId":"getResult",
           "parameters":[
              {
                 "$ref":"#/components/parameters/RequestId"
              }
           ],
           "responses":{
              "200":{
                 "$ref":"#/components/responses/ApprovalRequestResultResponse"
              },
              "default":{
                 "$ref":"#/components/responses/ErrorResponse"
              }
           },
           "security":[
              {
                 "bearerToken":[
                    
                 ]
              }
           ]
        }
     }
  },
  "components":{
     "schemas":{
        "Error":{
           "type":"object",
           "properties":{
              "message":{
                 "type":"string"
              }
           }
        },
        "BatchEncryptResponse":{
           "type":"array",
           "items":{
              "required":[
                 "status"
              ],
              "type":"object",
              "properties":{
                 "status":{
                    "type":"integer",
                    "description":"The HTTP status code for this partial request."
                 },
                 "error":{
                    "type":"string",
                    "description":"When the status property indicates an error, this contains the error message."
                 },
                 "body":{
                    "$ref":"#/components/schemas/EncryptResponse"
                 }
              }
           }
        },
        "BatchDecryptResponse":{
           "type":"array",
           "items":{
              "required":[
                 "status"
              ],
              "type":"object",
              "properties":{
                 "status":{
                    "type":"integer",
                    "description":"The HTTP status code for this partial request."
                 },
                 "error":{
                    "type":"string",
                    "description":"When the status property indicates an error, this contains the error message."
                 },
                 "body":{
                    "$ref":"#/components/schemas/DecryptResponse"
                 }
              }
           }
        },
        "BatchSignResponse":{
           "type":"array",
           "items":{
              "required":[
                 "status"
              ],
              "type":"object",
              "properties":{
                 "status":{
                    "type":"integer",
                    "description":"The HTTP status code for this partial request."
                 },
                 "error":{
                    "type":"string",
                    "description":"When the status property indicates an error, this contains the error message."
                 },
                 "body":{
                    "$ref":"#/components/schemas/SignResponse"
                 }
              }
           }
        },
        "BatchVerifyResponse":{
           "type":"array",
           "items":{
              "required":[
                 "status"
              ],
              "type":"object",
              "properties":{
                 "status":{
                    "type":"integer",
                    "description":"The HTTP status code for this partial request."
                 },
                 "error":{
                    "type":"string",
                    "description":"When the status property indicates an error, this contains the error message."
                 },
                 "body":{
                    "$ref":"#/components/schemas/VerifyResponse"
                 }
              }
           }
        },
        "BatchMacResponse":{
           "type":"array",
           "items":{
              "required":[
                 "status"
              ],
              "type":"object",
              "properties":{
                 "status":{
                    "type":"integer",
                    "description":"The HTTP status code for this partial request."
                 },
                 "error":{
                    "type":"string",
                    "description":"When the status property indicates an error, this contains the error message."
                 },
                 "body":{
                    "$ref":"#/components/schemas/MacGenerateResponse"
                 }
              }
           }
        },
        "Uuid":{
           "type":"string",
           "description":"Uuid format string, example - a41152ed-c26e-4c6e-a8d1-8820e36972c3"
        },
        "SobjectDescriptor":{
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string",
                 "description":"Key ID uniquely identifying this persisted security object."
              },
              "name":{
                 "type":"string",
                 "description":"Name of this persisted security object."
              },
              "transient_key":{
                 "type":"string",
                 "description":"Transient key blob."
              }
           },
           "description":"This uniquely identifies a persisted or transient sobject. Exactly one of `kid`, `name`, and `transient_key` must be present.\n"
        },
        "App":{
           "required":[
              "acct_id",
              "app_id",
              "app_type",
              "auth_type",
              "created_at",
              "creator",
              "default_group",
              "enabled",
              "groups",
              "name"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the application. Application names must be unique within an account."
              },
              "app_id":{
                 "type":"string",
                 "description":"Application ID uniquely identifying this application."
              },
              "auth_type":{
                 "$ref":"#/components/schemas/AppAuthType"
              },
              "description":{
                 "type":"string",
                 "description":"Description of this application."
              },
              "interface":{
                 "type":"string",
                 "description":"Interface used with this application (PKCS11, CNG, JCE, KMIP, etc.)."
              },
              "acct_id":{
                 "type":"string",
                 "description":"The account ID of the account that this application belongs to."
              },
              "groups":{
                 "type":"array",
                 "description":"An array of Security Group IDs. The application belongs to each Security Group in this array.",
                 "items":{
                    "type":"string",
                    "description":"A group ID (not name or description)."
                 }
              },
              "default_group":{
                 "type":"string",
                 "description":"The default group of this application. This is the group where security objects will be created by default by this application."
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this application is enabled."
              },
              "app_type":{
                 "type":"string",
                 "description":"The user-defined type of this application."
              },
              "creator":{
                 "$ref":"#/components/schemas/CreatorType"
              },
              "created_at":{
                 "type":"string",
                 "description":"When this application was created.",
                 "format":"dateTime"
              },
              "lastused_at":{
                 "type":"string",
                 "description":"When this application was last used.",
                 "format":"dateTime"
              },
              "oauth_config":{
                 "$ref":"#/components/schemas/AppOauthConfig"
              },
              "cert_not_after":{
                 "type":"string",
                 "description":"Certificate expiration date.",
                 "format":"dateTime"
              }
           }
        },
        "AppRequest":{
           "required":[
              "add_groups",
              "default_group",
              "name"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of this application. Application names must be unique within an account."
              },
              "description":{
                 "type":"string",
                 "description":"Description of this application."
              },
              "add_groups":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/AppPermissions"
                    }
                 },
                 "description":"Map from UUIDs to group permissions"
              },
              "del_groups":{
                 "type":"array",
                 "description":"Array of UUID of group",
                 "items":{
                    "type":"string",
                    "description":"A group ID (not name or description)."
                 }
              },
              "mod_groups":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/AppPermissions"
                    }
                 },
                 "description":"Map from UUIDs to group permissions"
              },
              "default_group":{
                 "type":"string",
                 "description":"The default group of this application. This is the group where security objects will be created by default by this application."
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this application is enabled"
              },
              "AppOauthConfig":{
                 "$ref":"#/components/schemas/AppOauthConfig"
              },
              "interface":{
                 "type":"string",
                 "description":"Interface used with this application (PKCS11, CNG, JCE, KMIP, etc.)."
              },
              "app_type":{
                 "type":"string",
                 "description":"The user-defined type of this application."
              },
              "credential":{
                 "$ref":"#/components/schemas/AppCredential"
              },
              "secret_size":{
                 "type":"integer",
                 "description":"Size in bytes of app's secret.",
                 "format":"int32"
              }
           }
        },
        "AppResetSecretRequest":{
           "type":"object",
           "properties":{
              "secret_size":{
                 "type":"integer",
                 "description":"Size in bytes of app's secret.",
                 "format":"int32"
              }
           }
        },
        "AppCredentialResponse":{
           "required":[
              "app_id",
              "credential"
           ],
           "type":"object",
           "properties":{
              "app_id":{
                 "type":"string",
                 "description":"Uuid format string, example - a41152ed-c26e-4c6e-a8d1-8820e36972c3"
              },
              "credential":{
                 "$ref":"#/components/schemas/AppCredential"
              }
           }
        },
        "Group":{
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the group. Group names must be unique within an account."
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID uniquely identifying this group."
              },
              "description":{
                 "type":"string",
                 "description":"Description of the group."
              },
              "acct_id":{
                 "type":"string",
                 "description":"Account ID of the account this Group belongs to."
              },
              "creator":{
                 "$ref":"#/components/schemas/CreatorType"
              },
              "created_at":{
                 "type":"string",
                 "description":"When this group was created.",
                 "format":"dateTime"
              },
              "hmg":{
                 "type":"object",
                 "additionalProperties":{
                    "$ref":"#/components/schemas/HmgConfig"
                 },
                 "description":"Map from UUIDs to HmgConfig objects"
              },
              "key_undo_policy":{
                 "$ref":"#/components/schemas/KeyUndoPolicy"
              }
           }
        },
        "GroupRequest":{
           "required":[
              "name"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the group. Group names must be unique within an account."
              },
              "description":{
                 "type":"string",
                 "description":"Description of the group."
              },
              "acct_id":{
                 "type":"string",
                 "description":"Account ID of the account the new group will belong to."
              },
              "add_hmg":{
                 "type":"array",
                 "description":"List of HmgConfig objects to add",
                 "items":{
                    "$ref":"#/components/schemas/HmgConfig"
                 }
              },
              "mod_hmg":{
                 "type":"object",
                 "additionalProperties":{
                    "$ref":"#/components/schemas/HmgConfig"
                 },
                 "description":"Map from UUIDs to HmgConfig objects to update"
              },
              "del_hmg":{
                 "type":"array",
                 "description":"List of HmgConfig UUIDs to delete",
                 "items":{
                    "type":"string",
                    "description":"Uuid format string, example - a41152ed-c26e-4c6e-a8d1-8820e36972c3"
                 }
              },
              "key_undo_policy":{
                 "$ref":"#/components/schemas/KeyUndoPolicy"
              }
           }
        },
        "IVEncryptInput":{
           "type":"string",
           "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
           "format":"byte"
        },
        "ADEncryptInput":{
           "type":"string",
           "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
           "format":"byte"
        },
        "TagLenEncryptInput":{
           "type":"integer",
           "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
           "format":"int32"
        },
        "IVEncryptOutput":{
           "type":"string",
           "description":"The initialiation value used for symmetric encryption. Not returned for asymmetric ciphers.",
           "format":"byte"
        },
        "TagEncryptOutput":{
           "type":"string",
           "description":"For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.\n",
           "format":"byte"
        },
        "IVDecryptInput":{
           "type":"string",
           "description":"The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.\n",
           "format":"byte"
        },
        "ADDecryptInput":{
           "type":"string",
           "description":"The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
           "format":"byte"
        },
        "TagDecryptInput":{
           "type":"string",
           "description":"The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
           "format":"byte"
        },
        "ObjectType":{
           "type":"string",
           "description":"Type of security object.",
           "default":"OPAQUE",
           "enum":[
              "AES",
              "DES",
              "DES3",
              "RSA",
              "DSA",
              "EC",
              "OPAQUE",
              "HMAC",
              "SECRET",
              "CERTIFICATE",
              "ROUND5BETA",
              "LEDABETA"
           ]
        },
        "KeyFormat":{
           "type":"string",
           "description":"Desired key formatting",
           "enum":[
              "Default",
              "Pkcs8"
           ]
        },
        "CipherMode":{
           "type":"string",
           "description":"Type of cipher mode, required for symmetric key algorithms.",
           "enum":[
              "ECB",
              "CBC",
              "CBCNOPAD",
              "CFB",
              "OFB",
              "CTR",
              "GCM",
              "CCM",
              "KW",
              "KWP"
           ]
        },
        "Mgf":{
           "type":"object",
           "properties":{
              "mgf1":{
                 "required":[
                    "hash"
                 ],
                 "type":"object",
                 "properties":{
                    "hash":{
                       "$ref":"#/components/schemas/DigestAlgorithm"
                    }
                 },
                 "description":"Parameters for MGF1."
              }
           },
           "description":"Specifies the Mask Generating Function (MGF) to use."
        },
        "RsaEncryptionPadding":{
           "type":"object",
           "properties":{
              "PKCS1_V15":{
                 "type":"object",
                 "properties":{
                    
                 },
                 "description":"PKCS#1 v1.5 padding"
              },
              "OAEP":{
                 "required":[
                    "mgf"
                 ],
                 "type":"object",
                 "properties":{
                    "mgf":{
                       "$ref":"#/components/schemas/Mgf"
                    }
                 },
                 "description":"Optimal Asymmetric Encryption Padding (PKCS#1 v2.1)"
              }
           },
           "description":"Type of padding to use for RSA encryption. The use of PKCS#1 v1.5 padding is strongly discouraged, because of its susceptibility to Bleichenbacher's attack. The padding specified must adhere to the key's encryption policy, see `RsaEncryptionPolicy`. If not specified, the default based on the key's policy will be used.\n"
        },
        "RsaSignaturePadding":{
           "type":"object",
           "properties":{
              "PKCS1_V15":{
                 "type":"object",
                 "properties":{
                    
                 },
                 "description":"PKCS#1 v1.5 padding"
              },
              "PSS":{
                 "required":[
                    "mgf"
                 ],
                 "type":"object",
                 "properties":{
                    "mgf":{
                       "$ref":"#/components/schemas/Mgf"
                    }
                 },
                 "description":"Probabilistic Signature Scheme (PKCS#1 v2.1)"
              }
           },
           "description":"Type of padding to use for RSA signatures. The padding specified must adhere to the key's signature policy, see `RsaSignaturePolicy`. If not specified, the default based on the key's policy will be used.\n"
        },
        "SignatureMode":{
           "type":"object",
           "properties":{
              "PKCS1_V15":{
                 "type":"object",
                 "properties":{
                    
                 },
                 "description":"PKCS#1 v1.5 padding"
              },
              "PSS":{
                 "required":[
                    "mgf"
                 ],
                 "type":"object",
                 "properties":{
                    "mgf":{
                       "$ref":"#/components/schemas/Mgf"
                    }
                 },
                 "description":"Probabilistic Signature Scheme (PKCS#1 v2.1)"
              }
           },
           "description":"Type of padding to use for RSA signatures. The padding specified must adhere to the key's signature policy, see `RsaSignaturePolicy`. If not specified, the default based on the key's policy will be used.\n"
        },
        "CryptMode":{
           "type":"string",
           "description":"`CipherMode` or `RsaEncryptionPadding`, depending on the encryption algorithm",
           "enum":[
              "ECB",
              "CBC",
              "CBCNOPAD",
              "CFB",
              "CTR",
              "OFB",
              "GCM",
              "CCM",
              "PKCS1_V15",
              "OAEP_MGF1_SHA1",
              "OAEP_MGF1_SHA256",
              "OAEP_MGF1_SHA384",
              "OAEP_MGF1_SHA512",
              "FPE",
              "KW",
              "KWP"
           ]
        },
        "AppCredential":{
           "type":"object",
           "properties":{
              "secret":{
                 "type":"string"
              },
              "certificate":{
                 "type":"string"
              },
              "trustedca":{
                 "required":[
                    "ca_certificate"
                 ],
                 "type":"object",
                 "properties":{
                    "subject":{
                       "type":"array",
                       "items":{
                          "maxItems":2,
                          "minItems":2,
                          "type":"array",
                          "items":{
                             "type":"string"
                          }
                       }
                    },
                    "ca_certificate":{
                       "type":"string"
                    }
                 }
              },
              "googleserviceaccount":{
                 "type":"object",
                 "properties":{
                    
                 }
              },
              "signedjwt":{
                 "required":[
                    "signing_keys",
                    "valid_issuers"
                 ],
                 "type":"object",
                 "properties":{
                    "valid_issuers":{
                       "type":"array",
                       "description":"An array of valid issuers. JWT presented for authentication must have one of these issuers.",
                       "items":{
                          "type":"string",
                          "description":"A valid issuer."
                       }
                    },
                    "signing_keys":{
                       "required":[
                          "kind"
                       ],
                       "type":"object",
                       "properties":{
                          "kind":{
                             "$ref":"#/components/schemas/JWTSigningKeyType"
                          },
                          "keys":{
                             "type":"object",
                             "additionalProperties":{
                                "type":"string"
                             },
                             "description":"In case of \"stored\" kind, a map of key ids (arbitrary strings) to base64-encoded DER keys"
                          },
                          "url":{
                             "type":"string",
                             "description":"In case of \"fetched\" kind, URL for fetching public key for verification of JWT signature"
                          },
                          "cache_duration":{
                             "type":"integer",
                             "description":"In case of \"fetched\" kind, duration for which the public key can be cached"
                          }
                       },
                       "description":"Details of signning key that will be used for signature verification."
                    }
                 },
                 "description":"Configuration for signed JWT authentication."
              }
           },
           "description":"Credential for an application."
        },
        "AppOauthConfig":{
           "type":"object",
           "properties":{
              "redirect_uris":{
                 "type":"array",
                 "items":{
                    "type":"string",
                    "description":"list of redirect uris for oauth"
                 }
              },
              "disabled":{
                 "type":"boolean",
                 "description":"Whether oauth for this app is disabled"
              }
           },
           "description":"Oauth configuration for this application."
        },
        "AppAuthType":{
           "type":"string",
           "description":"Authentication type for an application.",
           "enum":[
              "Secret",
              "Certificate",
              "TrustedCa",
              "GoogleServiceAccount",
              "SignedJwt"
           ]
        },
        "CreatorType":{
           "type":"object",
           "properties":{
              "app":{
                 "type":"string",
                 "description":"The application ID of the application that created this entity, if this entity was created by an application."
              },
              "user":{
                 "type":"string",
                 "description":"The user ID of the user who created this entity, if this entity was created by a user."
              }
           },
           "description":"What type of entity created another entity."
        },
        "ObjectOrigin":{
           "type":"string",
           "description":"Where this security object originated.",
           "enum":[
              "FortanixHSM",
              "External"
           ]
        },
        "DigestAlgorithm":{
           "type":"string",
           "description":"Message digest algorithm.",
           "enum":[
              "Blake2b256",
              "Blake2b384",
              "Blake2b512",
              "Blake2s256",
              "RIPEMD160",
              "SHA1",
              "SHA256",
              "SHA384",
              "SHA512",
              "SHA3_224",
              "SHA3_256",
              "SHA3_384",
              "SHA3_512",
              "Ssl3",
              "Streebog256",
              "Streebog512"
           ]
        },
        "AppPermissions":{
           "type":"string",
           "description":"Permissions allowed to be performed by an app.",
           "enum":[
              "ENCRYPT",
              "DECRYPT",
              "MASKDECRYPT",
              "WRAPKEY",
              "UNWRAPKEY",
              "DERIVEKEY",
              "MACGENERATE",
              "MACVERIFY",
              "MANAGE",
              "SIGN",
              "VERIFY",
              "AGREEKEY",
              "EXPORT"
           ]
        },
        "KeyOperations":{
           "type":"string",
           "description":"Operations allowed to be performed by a given key.",
           "enum":[
              "SIGN",
              "VERIFY",
              "ENCRYPT",
              "DECRYPT",
              "WRAPKEY",
              "UNWRAPKEY",
              "DERIVEKEY",
              "AGREEKEY",
              "MACGENERATE",
              "MACVERIFY",
              "EXPORT",
              "APPMANAGEABLE"
           ]
        },
        "EllipticCurve":{
           "type":"string",
           "description":"Identifies a standardized elliptic curve. Required for operations involving EC keys.",
           "enum":[
              "SecP192K1",
              "SecP224K1",
              "SecP256K1",
              "NistP192",
              "NistP224",
              "NistP256",
              "NistP384",
              "NistP521",
              "Gost256A",
              "Ed25519",
              "X25519",
              "X448"
           ]
        },
        "RevertRequest":{
           "required":[
              "ids"
           ],
           "type":"object",
           "properties":{
              "ids":{
                 "type":"array",
                 "description":"The IDs of the HistoryItems that should be reverted. In order to revert to a HistoryItem, that id of that HistoryItem and all more recent HistoryItems need to be provided.\n",
                 "items":{
                    "$ref":"#/components/schemas/Uuid"
                 }
              }
           }
        },
        "RevocationReasonCode":{
           "type":"string",
           "description":"Reasons to revoke a security object.",
           "enum":[
              "Unspecified",
              "KeyCompromise",
              "CACompromise",
              "AffiliationChanged",
              "Superseded",
              "CessationOfOperation",
              "PrivilegeWithdrawn"
           ]
        },
        "RevocationReason":{
           "required":[
              "code"
           ],
           "type":"object",
           "properties":{
              "code":{
                 "$ref":"#/components/schemas/RevocationReasonCode"
              },
              "message":{
                 "type":"string",
                 "description":"Field that is used exclusively for audit trail/logging purposes and MAY contain additional information about why the object was revoked."
              },
              "compromise_occurance_date":{
                 "type":"string",
                 "description":"An optional field specifying when this security object was compromised.",
                 "format":"dateTime"
              }
           }
        },
        "SobjectRequest":{
           "required":[
              "name",
              "obj_type"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the security object to create or import. Security object names must be unique within an account."
              },
              "description":{
                 "type":"string",
                 "description":"Description of the security object to create or import."
              },
              "key_size":{
                 "type":"integer",
                 "description":"Size in bits (not bytes) of the security object to create or import. Required for symmetric keys. For DSA keys, it represents the size of `p`; allowed values are 2048 or 3072. Deprecated for RSA keys, specify it in `RsaOptions` instead.",
                 "format":"int32"
              },
              "pub_exponent":{
                 "type":"integer",
                 "description":"For RSA keys only. Deprecated. Specify in `RsaOptions` instead. Public exponent to use when generating an RSA key.",
                 "format":"int32"
              },
              "elliptic_curve":{
                 "$ref":"#/components/schemas/EllipticCurve"
              },
              "rsa":{
                 "$ref":"#/components/schemas/RsaOptions"
              },
              "dsa":{
                 "$ref":"#/components/schemas/DsaOptions"
              },
              "fpe":{
                 "$ref":"#/components/schemas/FpeOptions"
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.\n"
              },
              "rotation_policy":{
                 "$ref":"#/components/schemas/RotationPolicy"
              },
              "obj_type":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "key_ops":{
                 "type":"array",
                 "description":"Optional array of key operations to be enabled for this security object. If this property is not provided, the DSM server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"User-defined metadata for this key. Stored as key-value pairs."
              },
              "value":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"When importing a security object, this field contains the binary contents to import. When creating a security object, this field is unused. The value of an OPAQUE or CERTIFICATE object is always returned. For other objects, the value is returned only with `/crypto/v1/keys/export` API (if the object is exportable).\n",
                 "format":"byte"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether the new security object should be enabled. Disabled security objects may not perform cryptographic operations.\n"
              },
              "transient":{
                 "type":"boolean",
                 "description":"If this is true, DSM will create a transient key."
              },
              "deterministic_signatures":{
                 "type":"boolean"
              },
              "state":{
                 "$ref":"#/components/schemas/KeyObjectState"
              },
              "deactivation_date":{
                 "type":"string",
                 "description":"When this object will be deactivated.",
                 "format":"dateTime"
              }
           }
        },
        "PersistTransientKeyRequest":{
           "required":[
              "name",
              "transient_key"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the persisted security object. Security object names must be unique within an account."
              },
              "description":{
                 "type":"string",
                 "description":"Description of the persisted security object."
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"User-defined metadata for the persisted key. Stored as key-value pairs."
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether the new security object should be enabled. Disabled security objects may not perform cryptographic operations.\n"
              },
              "key_ops":{
                 "type":"array",
                 "description":"Optional array of key operations to be enabled for this security object. If this property is not provided, the DSM server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID (not name) of the security group that the persisted security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.\n"
              },
              "transient_key":{
                 "type":"string",
                 "description":"Transient key blob."
              }
           }
        },
        "DeriveKeyMechanism":{
           "type":"object",
           "properties":{
              "encrypt_data":{
                 "$ref":"#/components/schemas/EncryptRequest"
              }
           },
           "description":"Encodes the mechanism to be used when deriving a new key from an existing key. Exactly one mechanism should be supplied. Currently, the only supported mechanism is encrypting data to derive the new key. Other mechanisms may be added in the future.\n"
        },
        "DeriveKeyRequest":{
           "required":[
              "key_size",
              "key_type",
              "mechanism",
              "name"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the derived key. Key names must be unique within an account."
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.\n"
              },
              "key_size":{
                 "type":"integer",
                 "description":"Key size of the derived key in bits (not bytes).",
                 "format":"int32"
              },
              "key_type":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mechanism":{
                 "$ref":"#/components/schemas/DeriveKeyMechanism"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether the derived key should have cryptographic operations enabled."
              },
              "description":{
                 "type":"string",
                 "description":"Description for the new key."
              },
              "key_ops":{
                 "type":"array",
                 "description":"Optional array of key operations to be enabled for this security object. If this property is not provided, the DSM server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"User-defined metadata for this key. Stored as key-value pairs."
              }
           }
        },
        "DeriveKeyRequestEx":{
           "required":[
              "key",
              "key_size",
              "key_type",
              "mechanism",
              "name"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "name":{
                 "type":"string",
                 "description":"Name of the derived key. Key names must be unique within an account."
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.\n"
              },
              "key_size":{
                 "type":"integer",
                 "description":"Key size of the derived key in bits (not bytes).",
                 "format":"int32"
              },
              "key_type":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mechanism":{
                 "$ref":"#/components/schemas/DeriveKeyMechanism"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether the derived key should have cryptographic operations enabled."
              },
              "description":{
                 "type":"string",
                 "description":"Description for the new key."
              },
              "key_ops":{
                 "type":"array",
                 "description":"Optional array of key operations to be enabled for this security object. If this property is not provided, the DSM server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"User-defined metadata for this key. Stored as key-value pairs."
              },
              "transient":{
                 "type":"boolean",
                 "description":"If this is true, DSM will derive a transient key."
              }
           }
        },
        "AgreeKeyMechanism":{
           "type":"string",
           "description":"Mechanism to use for key agreement.",
           "default":"diffie_hellman",
           "enum":[
              "diffie_hellman"
           ]
        },
        "AgreeKeyRequest":{
           "required":[
              "key_size",
              "key_type",
              "mechanism",
              "name",
              "private_key",
              "public_key"
           ],
           "type":"object",
           "properties":{
              "private_key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "public_key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "name":{
                 "type":"string",
                 "description":"Name of the agreed-upon key. Key names must be unique within an account. The name is ignored for transient keys and should be the empty string."
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.\n"
              },
              "key_size":{
                 "type":"integer",
                 "description":"Key size of the derived key in bits (not bytes).",
                 "format":"int32"
              },
              "key_type":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mechanism":{
                 "$ref":"#/components/schemas/AgreeKeyMechanism"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether the derived key should have cryptographic operations enabled."
              },
              "description":{
                 "type":"string",
                 "description":"Description for the new key."
              },
              "key_ops":{
                 "type":"array",
                 "description":"Optional array of key operations to be enabled for this security object. If this property is not provided, the DSM server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"User-defined metadata for this key. Stored as key-value pairs."
              },
              "transient":{
                 "type":"boolean",
                 "description":"If this is true, DSM will derive a transient key."
              }
           }
        },
        "KeyObject":{
           "required":[
              "acct_id",
              "created_at",
              "creator",
              "enabled",
              "lastused_at",
              "name",
              "never_exportable",
              "obj_type",
              "origin"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the security object."
              },
              "description":{
                 "type":"string",
                 "description":"Description of the security object."
              },
              "key_size":{
                 "type":"integer",
                 "description":"For objects which are not elliptic curves, this is the size in bits (not bytes) of the object. This field is not returned for elliptic curves.\n",
                 "format":"int32"
              },
              "elliptic_curve":{
                 "$ref":"#/components/schemas/EllipticCurve"
              },
              "acct_id":{
                 "type":"string",
                 "description":"Account ID of the account this security object belongs to."
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID of the security group that this security object belongs to."
              },
              "creator":{
                 "$ref":"#/components/schemas/CreatorType"
              },
              "kid":{
                 "type":"string",
                 "description":"Key ID uniquely identifying this security object."
              },
              "obj_type":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "key_ops":{
                 "type":"array",
                 "description":"Array of key operations enabled for this security object.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"User-defined metadata for this key. Stored as key-value pairs."
              },
              "origin":{
                 "$ref":"#/components/schemas/ObjectOrigin"
              },
              "pub_key":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"This field is returned only for asymmetric keys. It contains the public key.",
                 "format":"byte"
              },
              "value":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"This field is returned only for opaque and secret objects. It contains the contents of the object.",
                 "format":"byte"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this security object has cryptographic operations enabled."
              },
              "compliant_with_policies":{
                 "type":"boolean",
                 "description":"Whether this security object is compliant with cryptographic policies or not."
              },
              "created_at":{
                 "type":"string",
                 "description":"When this security object was created.",
                 "format":"dateTime"
              },
              "lastused_at":{
                 "type":"string",
                 "description":"When this security object was last used.",
                 "format":"dateTime"
              },
              "transient_key":{
                 "type":"string",
                 "description":"Transient key blob."
              },
              "never_exportable":{
                 "type":"boolean",
                 "description":"True if this key's operations have never contained EXPORT."
              },
              "rsa":{
                 "$ref":"#/components/schemas/RsaOptions"
              },
              "kcv":{
                 "type":"string",
                 "description":"KCV for the Security Object"
              },
              "state":{
                 "$ref":"#/components/schemas/KeyObjectState"
              },
              "history":{
                 "type":"array",
                 "description":"When a Key Undo Policy is in place, a list of (non-expired) history items is returned. Each history item represents a passed key state that can be reverted to.",
                 "items":{
                    "$ref":"#/components/schemas/HistoryItem"
                 }
              }
           }
        },
        "HistoryItem":{
           "type":"object",
           "properties":{
              "id":{
                 "type":"string",
                 "description":"History item ID uniquely identifying this history item"
              },
              "state":{
                 "$ref":"#/components/schemas/HistoryItemState"
              },
              "created_at":{
                 "type":"string",
                 "description":"Date and time this history item was created",
                 "format":"dateTime"
              },
              "expiry":{
                 "type":"string",
                 "description":"Date and time this history item will expire. KeyObjects cannot be reverted to expired history items.",
                 "format":"dateTime"
              }
           }
        },
        "HistoryItemState":{
           "type":"object",
           "properties":{
              "activation_date":{
                 "type":"string",
                 "description":"When this KeyObject will become active",
                 "format":"dateTime"
              },
              "revocation_reason":{
                 "$ref":"#/components/schemas/RevocationReasonCode"
              },
              "compromise_date":{
                 "type":"string",
                 "description":"When this security object was compromised.",
                 "format":"dateTime"
              },
              "deactivation_date":{
                 "type":"string",
                 "description":"When this security object was deactivated",
                 "format":"dateTime"
              },
              "destruction_date":{
                 "type":"string",
                 "description":"When this security object was destroyed",
                 "format":"dateTime"
              },
              "deletion_date":{
                 "type":"string",
                 "description":"When the security object was deleted",
                 "format":"dateTime"
              },
              "state":{
                 "$ref":"#/components/schemas/KeyObjectState"
              },
              "key_ops":{
                 "type":"array",
                 "description":"Array of key operations enabled for this security object.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "public_only":{
                 "type":"boolean",
                 "description":"Whether the key object contains only a public part"
              },
              "rotation_policy":{
                 "$ref":"#/components/schemas/RotationPolicy"
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID (UUID) of the security group that this security object belonged to. Expect this property to always exist."
              }
           }
        },
        "KeyObjectState":{
           "type":"string",
           "description":"State of the key object",
           "enum":[
              "None",
              "PreActive",
              "Active",
              "Deactivated",
              "Compromised",
              "Destroyed",
              "Deleted"
           ]
        },
        "RotationPolicy":{
           "type":"object",
           "properties":{
              "interval":{
                 "$ref":"#/components/schemas/RotationInterval"
              },
              "effective_at":{
                 "type":"string",
                 "description":"Start time of the rotation policy",
                 "format":"dateTime"
              },
              "deactivate_rotated_key":{
                 "type":"boolean",
                 "description":"Upon key rotation, the old key will automatically be deactivated. This only affects keys that were in the Preactive or Active state."
              }
           }
        },
        "RotationInterval":{
           "type":"object",
           "properties":{
              "interval_days":{
                 "type":"integer"
              },
              "interval_months":{
                 "type":"integer"
              }
           },
           "description":"Interval between key objects are rotated"
        },
        "BatchEncryptRequest":{
           "type":"array",
           "items":{
              "required":[
                 "kid",
                 "request"
              ],
              "type":"object",
              "properties":{
                 "kid":{
                    "type":"string",
                    "description":"Key ID (not name or description) of the key to use to encrypt request.\n"
                 },
                 "request":{
                    "$ref":"#/components/schemas/EncryptRequest"
                 }
              }
           }
        },
        "BatchDecryptRequest":{
           "type":"array",
           "items":{
              "required":[
                 "kid",
                 "request"
              ],
              "type":"object",
              "properties":{
                 "kid":{
                    "type":"string",
                    "description":"Key ID (not name or description) of the key to use to decrypt request.\n"
                 },
                 "request":{
                    "$ref":"#/components/schemas/DecryptRequest"
                 }
              }
           }
        },
        "BatchSignRequest":{
           "type":"array",
           "description":"Array of Sign requests to be performed in batch\n",
           "items":{
              "$ref":"#/components/schemas/SignRequestEx"
           }
        },
        "BatchVerifyRequest":{
           "type":"array",
           "description":"Array of Verify requests to be performed in batch\n",
           "items":{
              "$ref":"#/components/schemas/VerifyRequestEx"
           }
        },
        "BatchMacRequest":{
           "type":"array",
           "description":"Array of Mac requests to be performed in batch\n",
           "items":{
              "$ref":"#/components/schemas/MacGenerateRequestEx"
           }
        },
        "BatchMacVerifyRequest":{
           "type":"array",
           "description":"Array of Mac Verify requests to be performed in batch\n",
           "items":{
              "$ref":"#/components/schemas/MacVerifyRequestEx"
           }
        },
        "ExportSobjectComponentsRequest":{
           "required":[
              "custodians",
              "key",
              "method",
              "wrap_key_params"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "wrap_key_params":{
                 "$ref":"#/components/schemas/WrapKeyParams"
              },
              "custodians":{
                 "type":"array",
                 "description":"Map from USER or App to its UUIDs",
                 "items":{
                    "$ref":"#/components/schemas/CreatorType"
                 }
              },
              "method":{
                 "$ref":"#/components/schemas/SplittingMethod"
              },
              "description":{
                 "type":"string",
                 "description":"description to the export request"
              }
           },
           "description":"Request to export security object as components"
        },
        "ExportComponentsResponse":{
           "required":[
              "components",
              "key_kcv"
           ],
           "type":"object",
           "properties":{
              "components":{
                 "type":"array",
                 "description":"Components of the Security Object",
                 "items":{
                    "$ref":"#/components/schemas/SobjectComponent"
                 }
              },
              "key_kcv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"KCV for the entire Security Object",
                 "format":"byte"
              },
              "description":{
                 "type":"string",
                 "description":"optional description to the export request"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.\n",
                 "format":"byte"
              }
           },
           "description":"Response of security object export components operation"
        },
        "ImportSobjectComponentsRequest":{
           "required":[
              "components",
              "custodians",
              "key",
              "method",
              "unwrap_key_params"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectRequest"
              },
              "unwrap_key_params":{
                 "$ref":"#/components/schemas/UnwrapKeyParams"
              },
              "custodians":{
                 "type":"array",
                 "description":"Map from USER or App to its UUIDs",
                 "items":{
                    "$ref":"#/components/schemas/CreatorType"
                 }
              },
              "components":{
                 "type":"array",
                 "description":"An array of Security Object components",
                 "items":{
                    "$ref":"#/components/schemas/SobjectComponent"
                 }
              },
              "description":{
                 "type":"string"
              },
              "method":{
                 "$ref":"#/components/schemas/SplittingMethod"
              }
           },
           "description":"Request body to import security objcet components"
        },
        "WrapKeyParams":{
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mode":{
                 "$ref":"#/components/schemas/CipherMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
                 "format":"byte"
              },
              "tag_len":{
                 "type":"integer",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
                 "format":"int32"
              }
           },
           "description":"Security Object wrapping parameters"
        },
        "UnwrapKeyParams":{
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mode":{
                 "$ref":"#/components/schemas/CipherMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
                 "format":"byte"
              },
              "tag_len":{
                 "type":"integer",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
                 "format":"int32"
              }
           },
           "description":"Security Object unwrapping parameters"
        },
        "SobjectComponent":{
           "type":"object",
           "properties":{
              "component":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"component of Security Object",
                 "format":"byte"
              },
              "component_kcv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"component kcv value",
                 "format":"byte"
              },
              "custodian":{
                 "$ref":"#/components/schemas/CreatorType"
              }
           },
           "description":"Security Object components"
        },
        "SplittingMethod":{
           "type":"string",
           "description":"Key split method `XOR`",
           "enum":[
              "XOR"
           ]
        },
        "EncryptRequest":{
           "required":[
              "alg",
              "plain"
           ],
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "plain":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The plaintext to encrypt.",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/CryptMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
                 "format":"byte"
              },
              "tag_len":{
                 "type":"integer",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
                 "format":"int32"
              }
           },
           "description":"A request to encrypt data using a symmetric or asymmetric key."
        },
        "EncryptRequestEx":{
           "required":[
              "alg",
              "key",
              "plain"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "plain":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The plaintext to encrypt.",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/CryptMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
                 "format":"byte"
              },
              "tag_len":{
                 "type":"integer",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
                 "format":"int32"
              }
           },
           "description":"A request to encrypt data using a symmetric or asymmetric key."
        },
        "EncryptResponse":{
           "required":[
              "cipher"
           ],
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string",
                 "description":"ID of the key used to perform encryption."
              },
              "cipher":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The encrypted data.",
                 "format":"byte"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialiation value used for symmetric encryption. Not returned for asymmetric ciphers.",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.\n",
                 "format":"byte"
              }
           }
        },
        "EncryptInitRequest":{
           "required":[
              "alg"
           ],
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mode":{
                 "$ref":"#/components/schemas/CipherMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
                 "format":"byte"
              }
           },
           "description":"alg is required. mode is required for symmetric algorithms."
        },
        "EncryptInitRequestEx":{
           "required":[
              "alg",
              "key"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mode":{
                 "$ref":"#/components/schemas/CipherMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
                 "format":"byte"
              }
           },
           "description":"alg is required. mode is required for symmetric algorithms."
        },
        "EncryptInitResponse":{
           "required":[
              "state"
           ],
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialiation value used for symmetric encryption. Not returned for asymmetric ciphers.",
                 "format":"byte"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              }
           }
        },
        "EncryptUpdateRequest":{
           "required":[
              "plain",
              "state"
           ],
           "type":"object",
           "properties":{
              "plain":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Plaintext to encrypt.",
                 "format":"byte"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              }
           },
           "description":"all fields are required"
        },
        "EncryptUpdateRequestEx":{
           "required":[
              "key",
              "plain",
              "state"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "plain":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Plaintext to encrypt.",
                 "format":"byte"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              }
           },
           "description":"all fields are required"
        },
        "EncryptUpdateResponse":{
           "required":[
              "cipher",
              "state"
           ],
           "type":"object",
           "properties":{
              "cipher":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Encrypted data.",
                 "format":"byte"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              }
           }
        },
        "EncryptFinalRequest":{
           "required":[
              "state"
           ],
           "type":"object",
           "properties":{
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              },
              "tag_len":{
                 "type":"integer",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
                 "format":"int32"
              }
           },
           "description":"all fields are required"
        },
        "EncryptFinalRequestEx":{
           "required":[
              "key",
              "state"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              },
              "tag_len":{
                 "type":"integer",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
                 "format":"int32"
              }
           },
           "description":"all fields are required"
        },
        "EncryptFinalResponse":{
           "required":[
              "cipher"
           ],
           "type":"object",
           "properties":{
              "cipher":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Encrypted data.",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.\n",
                 "format":"byte"
              }
           }
        },
        "EncryptRequestFrame":{
           "type":"object",
           "properties":{
              "init":{
                 "required":[
                    "key",
                    "mode"
                 ],
                 "type":"object",
                 "properties":{
                    "key":{
                       "$ref":"#/components/schemas/SobjectDescriptor"
                    },
                    "mode":{
                       "$ref":"#/components/schemas/CipherMode"
                    },
                    "alg":{
                       "$ref":"#/components/schemas/ObjectType"
                    },
                    "iv":{
                       "type":"string",
                       "description":"The initialization vector to use for encryption.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  If not provided, one is randomly generated.  If provided, the length must match the length required by the cipher and mode.\n",
                       "format":"binary"
                    },
                    "tag_len":{
                       "type":"integer",
                       "description":"In AEAD modes, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required in AEAD modes, and forbidden otherwise.\n"
                    }
                 }
              },
              "ad":{
                 "type":"string",
                 "description":"A chunk of additional data for authentication in AEAD modes.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  All \"ad\" frames must come before any \"plain\" frames.\n",
                 "format":"binary"
              },
              "plain":{
                 "type":"string",
                 "description":"A chunk of ciphertext.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  In addition to the 512 KiB limit on the total size of all frames, the content of this field may be at most 511 KiB.\n",
                 "format":"binary"
              },
              "final":{
                 "type":"object",
                 "properties":{
                    
                 },
                 "description":"All requests must end with a \"final\" frame.  The value is the empty object (a CBOR map with zero items).\n"
              }
           },
           "description":"A single frame of an encrypt request.  Each frame is a CBOR map with exactly one string key: \"init\", \"ad\", \"plain\", or \"final\".\n"
        },
        "EncryptResponseFrame":{
           "type":"object",
           "properties":{
              "init":{
                 "type":"object",
                 "properties":{
                    "kid":{
                       "type":"string",
                       "description":"Key ID of the key used for encryption."
                    },
                    "iv":{
                       "type":"string",
                       "description":"The initialization vector to use for encryption.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  This is provided in all modes except ECB.\n",
                       "format":"binary"
                    }
                 }
              },
              "cipher":{
                 "type":"string",
                 "description":"A chunk of ciphertext.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.\n",
                 "format":"binary"
              },
              "final":{
                 "type":"object",
                 "properties":{
                    "tag":{
                       "type":"string",
                       "description":"The authentication tag.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  This field is only present in AEAD modes.\n",
                       "format":"binary"
                    }
                 },
                 "description":"The response ends with a single \"final\" frame, indicating success.\n"
              },
              "error":{
                 "type":"object",
                 "properties":{
                    "status":{
                       "type":"integer",
                       "description":"A status code with the same semantics as in HTTP.",
                       "format":"uint16"
                    },
                    "message":{
                       "type":"string",
                       "description":"A human-readable description of the error."
                    }
                 },
                 "description":"An error message.  After an \"error\" frame, no further data is sent.\n"
              }
           },
           "description":"A single frame of an encrypt response.  Each frame is a CBOR map with exactly one string key: \"init\", \"cipher\", \"final\", or \"error\".\n"
        },
        "DecryptRequest":{
           "required":[
              "cipher"
           ],
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "cipher":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The ciphertext to decrypt.",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/CryptMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              },
              "masked":{
                 "type":"boolean",
                 "description":"This flag is only useful with DECRYPT permission. When this flag is true, decryption returns masked output. Setting it to false is equivalent to not using this flag. With MASKDECRYPT permission, this flag is ignored.\n"
              }
           },
           "description":"Mode and iv are required fields for symmetric key algorithms and ad and tag are required fields for GCM or CCM modes."
        },
        "DecryptRequestEx":{
           "required":[
              "cipher",
              "key"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "cipher":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The ciphertext to decrypt.",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/CryptMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              }
           },
           "description":"Mode and iv are required fields for symmetric key algorithms and ad and tag are required fields for GCM or CCM modes."
        },
        "DecryptResponse":{
           "required":[
              "plain"
           ],
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string",
                 "description":"The key ID of the key used to decrypt."
              },
              "plain":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The decrypted plaintext.",
                 "format":"byte"
              }
           }
        },
        "DecryptInitRequest":{
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mode":{
                 "$ref":"#/components/schemas/CipherMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              }
           },
           "description":"all fields are optional"
        },
        "DecryptInitRequestEx":{
           "required":[
              "key"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mode":{
                 "$ref":"#/components/schemas/CipherMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              }
           }
        },
        "DecryptInitResponse":{
           "required":[
              "state"
           ],
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              }
           }
        },
        "DecryptUpdateRequest":{
           "required":[
              "cipher",
              "state"
           ],
           "type":"object",
           "properties":{
              "cipher":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Ciphertext to decrypt.",
                 "format":"byte"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              }
           },
           "description":"all fields are required"
        },
        "DecryptUpdateRequestEx":{
           "required":[
              "cipher",
              "key",
              "state"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "cipher":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Ciphertext to decrypt.",
                 "format":"byte"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              }
           },
           "description":"all fields are required"
        },
        "DecryptUpdateResponse":{
           "required":[
              "plain",
              "state"
           ],
           "type":"object",
           "properties":{
              "plain":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Decrypted plaintext.",
                 "format":"byte"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              }
           }
        },
        "DecryptFinalRequest":{
           "required":[
              "state"
           ],
           "type":"object",
           "properties":{
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              }
           },
           "description":"all fields are required"
        },
        "DecryptFinalRequestEx":{
           "required":[
              "key",
              "state"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "state":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              }
           },
           "description":"all fields are required"
        },
        "DecryptFinalResponse":{
           "required":[
              "plain"
           ],
           "type":"object",
           "properties":{
              "plain":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Decrypted plaintext.",
                 "format":"byte"
              }
           }
        },
        "DecryptRequestFrame":{
           "type":"object",
           "properties":{
              "init":{
                 "required":[
                    "key",
                    "mode"
                 ],
                 "type":"object",
                 "properties":{
                    "key":{
                       "$ref":"#/components/schemas/SobjectDescriptor"
                    },
                    "mode":{
                       "$ref":"#/components/schemas/CipherMode"
                    },
                    "iv":{
                       "type":"string",
                       "description":"The initialization vector used to encrypt this ciphertext.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  This field is required for all modes except ECB, where it is forbidden.\n",
                       "format":"binary"
                    }
                 },
                 "description":"All requests must have exactly one \"init\" frame, sent before any other frames.\n"
              },
              "ad":{
                 "type":"string",
                 "description":"A chunk of additional data for authentication in AEAD modes.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  All \"ad\" frames must come before any \"cipher\" frames.\n",
                 "format":"binary"
              },
              "cipher":{
                 "type":"string",
                 "description":"A chunk of ciphertext.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  In addition to the 512 KiB limit on the total size of all frames, the content of this field may be at most 511 KiB.\n",
                 "format":"binary"
              },
              "final":{
                 "type":"object",
                 "properties":{
                    "tag":{
                       "type":"string",
                       "description":"The authentication tag to verify.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.  In AEAD modes, this field is required, otherwise it is forbidden.\n",
                       "format":"binary"
                    }
                 },
                 "description":"All requests must end with a \"final\" frame.\n"
              }
           },
           "description":"A single frame of a decrypt request.  Each frame is a CBOR map with exactly one string key: \"init\", \"ad\", \"cipher\", or \"final\".\n"
        },
        "DecryptResponseFrame":{
           "type":"object",
           "properties":{
              "init":{
                 "type":"object",
                 "properties":{
                    "kid":{
                       "type":"string",
                       "description":"Key ID of the key used for decryption."
                    }
                 },
                 "description":"The response begins with a single \"init\" frame, and no other init frames appear.\n"
              },
              "plain":{
                 "type":"string",
                 "description":"A chunk of plaintext.  In CBOR, this is encoded directly as a byte string, *not* a UTF-8 string.\n",
                 "format":"binary"
              },
              "final":{
                 "type":"object",
                 "properties":{
                    
                 },
                 "description":"The response ends with a single \"final\" frame, indicating success.\n"
              },
              "error":{
                 "type":"object",
                 "properties":{
                    "status":{
                       "type":"integer",
                       "description":"A status code with the same semantics as in HTTP.",
                       "format":"uint16"
                    },
                    "message":{
                       "type":"string",
                       "description":"A human-readable description of the error."
                    }
                 },
                 "description":"An error message.  After an \"error\" frame, no further data is sent.\n"
              }
           },
           "description":"A single frame of an decrypt response.  Each frame is a CBOR map with exactly one string key: \"init\", \"plain\", \"final\", or \"error\".\n"
        },
        "SignRequest":{
           "required":[
              "hash_alg"
           ],
           "type":"object",
           "properties":{
              "hash_alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "hash":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Hash (not supported in FIPS mode) of the data to be signed. Exactly one of `hash` and `data` is required.\n",
                 "format":"byte"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Data to be signed. Exactly one of `hash` and `data` is required. To reduce request size and avoid reaching the request size limit, prefer `hash`. When using Ed25519 keys, a distinction is made between providing the message directly in `data` and providing a prehashed value in `hash`. Providing a full message results in an \"Ed25519\" signature while providing `hash` results in an \"Ed25519ph\" signature, which is not compatible. See RFC 8032 for details.\n",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/SignatureMode"
              },
              "deterministic_signature":{
                 "type":"boolean"
              }
           }
        },
        "SignRequestEx":{
           "required":[
              "hash_alg",
              "key"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "hash_alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "hash":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Hash (not supported in FIPS mode) of the data to be signed. Exactly one of `hash` and `data` is required.\n",
                 "format":"byte"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Data to be signed. Exactly one of `hash` and `data` is required. To reduce request size and avoid reaching the request size limit, prefer `hash`.\n",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/SignatureMode"
              }
           }
        },
        "SignResponse":{
           "required":[
              "signature"
           ],
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string",
                 "description":"Key ID of the key used to sign this data."
              },
              "signature":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Signature of the data's hash.",
                 "format":"byte"
              }
           }
        },
        "VerifyRequest":{
           "required":[
              "hash_alg",
              "signature"
           ],
           "type":"object",
           "properties":{
              "hash_alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "hash":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The hash (not supported in FIPS mode) of the data on which the signature is being verified. Exactly one of `hash` and `data` is required.\n",
                 "format":"byte"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The data on which the signature is being verified. Exactly one of `hash` and `data` is required. To reduce request size and avoid reaching the request size limit, prefer `hash`.\n",
                 "format":"byte"
              },
              "signature":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"A signature created with the private key corresponding to this public key.",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/SignatureMode"
              }
           }
        },
        "VerifyRequestEx":{
           "required":[
              "hash_alg",
              "key",
              "signature"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "hash_alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "hash":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The hash (not supported in FIPS mode) of the data on which the signature is being verified. Exactly one of `hash` and `data` is required.\n",
                 "format":"byte"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The data on which the signature is being verified. Exactly one of `hash` and `data` is required. To reduce request size and avoid reaching the request size limit, prefer `hash`.\n",
                 "format":"byte"
              },
              "signature":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"A signature created with the private key corresponding to this public key.",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/SignatureMode"
              }
           }
        },
        "VerifyResponse":{
           "required":[
              "result"
           ],
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string",
                 "description":"The Key ID of the key used to verify this data."
              },
              "result":{
                 "type":"boolean",
                 "description":"True if the signature verified and False if it did not."
              }
           }
        },
        "DigestRequest":{
           "required":[
              "alg",
              "data"
           ],
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Data to be hashed.",
                 "format":"byte"
              }
           }
        },
        "ObjectDigestRequest":{
           "required":[
              "alg",
              "key"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              }
           }
        },
        "VerifyKcvRequest":{
           "required":[
              "kcv",
              "obj_type",
              "value"
           ],
           "type":"object",
           "properties":{
              "kcv":{
                 "type":"string",
                 "description":"KCV to verify against provided key material in 'value'"
              },
              "value":{
                 "type":"string",
                 "description":"Key material"
              },
              "obj_type":{
                 "$ref":"#/components/schemas/ObjectType"
              }
           }
        },
        "VerifyKcvResponse":{
           "required":[
              "verified"
           ],
           "type":"object",
           "properties":{
              "verified":{
                 "type":"boolean",
                 "description":"True if the KCV successfully verified, and false if it did not."
              }
           }
        },
        "DigestResponse":{
           "required":[
              "digest"
           ],
           "type":"object",
           "properties":{
              "digest":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Hash of the data.",
                 "format":"byte"
              }
           }
        },
        "MacGenerateRequest":{
           "required":[
              "data"
           ],
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Data to compute the MAC of.",
                 "format":"byte"
              }
           }
        },
        "MacGenerateRequestEx":{
           "required":[
              "data",
              "key"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"Data to compute the MAC of.",
                 "format":"byte"
              }
           }
        },
        "MacGenerateResponse":{
           "required":[
              "mac"
           ],
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string",
                 "description":"Key ID of the key used to generate the MAC."
              },
              "digest":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The MAC generated for the input data (returned for HMAC operation).",
                 "format":"byte"
              },
              "mac":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The MAC generated for the input data (returned for CMAC operation).",
                 "format":"byte"
              }
           }
        },
        "MacVerifyRequest":{
           "required":[
              "alg",
              "data"
           ],
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The data to verify the MAC of.",
                 "format":"byte"
              },
              "digest":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The MAC previously computed for the input data. NOTE - this field is deprecated. Instead you should use mac field.",
                 "format":"byte"
              },
              "mac":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The MAC previously computed for the input data.",
                 "format":"byte"
              }
           }
        },
        "MacVerifyRequestEx":{
           "required":[
              "alg",
              "data",
              "key"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/DigestAlgorithm"
              },
              "data":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The data to verify the MAC of.",
                 "format":"byte"
              },
              "digest":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The MAC previously computed for the input data. NOTE - this field is deprecated. Instead you should use mac field.",
                 "format":"byte"
              },
              "mac":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The MAC previously computed for the input data.",
                 "format":"byte"
              }
           }
        },
        "MacVerifyResponse":{
           "required":[
              "result"
           ],
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string",
                 "description":"Key ID of the key used to verify the MAC."
              },
              "result":{
                 "type":"boolean",
                 "description":"True if the MAC successfully verified, and false if it did not."
              }
           }
        },
        "AuthResponse":{
           "required":[
              "access_token",
              "entity_id",
              "expires_in"
           ],
           "type":"object",
           "properties":{
              "expires_in":{
                 "type":"integer",
                 "description":"Number of seconds from token issuance that the token will expire."
              },
              "access_token":{
                 "type":"string",
                 "description":"Bearer token to be used to authenticate to other APIs."
              },
              "entity_id":{
                 "type":"string",
                 "description":"The UUID of the entity that was authorized. For users, this will be the user's UUID. For applications, this will be the application's UUID.\n"
              }
           }
        },
        "SubscriptionType":{
           "type":"object",
           "description":"Type of Subscription."
        },
        "SubscriptionChangeRequest":{
           "required":[
              "subscription"
           ],
           "type":"object",
           "properties":{
              "subscription":{
                 "$ref":"#/components/schemas/SubscriptionType"
              },
              "contact":{
                 "type":"string",
                 "description":"contact information, e.g. phone number"
              },
              "comment":{
                 "type":"string",
                 "description":"additional comments"
              }
           },
           "description":"Describes a request to update subscription."
        },
        "NotificationPref":{
           "type":"string",
           "description":"Type of notification preference.",
           "enum":[
              "None",
              "Email",
              "Phone",
              "Both"
           ]
        },
        "AccountState":{
           "type":"string",
           "description":"State of account.",
           "enum":[
              "PendingConfirmation",
              "Activated",
              "Disabled"
           ]
        },
        "AuthType":{
           "type":"string",
           "description":"Type of authentication.",
           "enum":[
              "Fortanix",
              "FortanixMFA",
              "External"
           ]
        },
        "Account":{
           "required":[
              "acct_id",
              "auth_type",
              "name",
              "state",
              "subscription"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the account. Account names must be unique within an DSM instance."
              },
              "acct_id":{
                 "type":"string",
                 "description":"Account ID uniquely identifying this account."
              },
              "description":{
                 "type":"string",
                 "description":"Description of this account."
              },
              "organization":{
                 "type":"string",
                 "description":"Organization (e.g. company name) that owns this account"
              },
              "country":{
                 "type":"string",
                 "description":"Main country associated with this account"
              },
              "phone":{
                 "type":"string",
                 "description":"Contact phone number associated with this account"
              },
              "notification_pref":{
                 "$ref":"#/components/schemas/NotificationPref"
              },
              "auth_config":{
                 "$ref":"#/components/schemas/AuthConfig"
              },
              "subscription":{
                 "$ref":"#/components/schemas/SubscriptionType"
              },
              "state":{
                 "$ref":"#/components/schemas/AccountState"
              },
              "auth_type":{
                 "$ref":"#/components/schemas/AuthType"
              },
              "logging_configs":{
                 "type":"object",
                 "additionalProperties":{
                    "$ref":"#/components/schemas/LoggingConfig"
                 },
                 "description":"Map from UUIDs to LoggingConfig objects"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this account is enabled. This may only be changed by sysadmins."
              },
              "created_at":{
                 "type":"string",
                 "description":"When this account was created.",
                 "format":"dateTime"
              },
              "initial_purchase_at":{
                 "type":"string",
                 "description":"When this accout was upgraded a paid subscription.",
                 "format":"dateTime"
              },
              "pending_subscription_change_request":{
                 "$ref":"#/components/schemas/SubscriptionChangeRequest"
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"Sysadmin-defined metadata for this account. Stored as key-value pairs. This field is only visible to sysadmin users.\n"
              },
              "key_undo_policy":{
                 "$ref":"#/components/schemas/KeyUndoPolicy"
              }
           }
        },
        "AccountRequest":{
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the account. Accounts must be unique within an DSM instance."
              },
              "description":{
                 "type":"string",
                 "description":"Account ID uniquely identifying this account."
              },
              "organization":{
                 "type":"string",
                 "description":"Organization (e.g. company name) that owns this account"
              },
              "country":{
                 "type":"string",
                 "description":"Main country associated with this account"
              },
              "phone":{
                 "type":"string",
                 "description":"Contact phone number associated with this account"
              },
              "notification_pref":{
                 "$ref":"#/components/schemas/NotificationPref"
              },
              "auth_config":{
                 "$ref":"#/components/schemas/AuthConfig"
              },
              "add_logging_configs":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/LoggingConfigRequest"
                 }
              },
              "mod_logging_configs":{
                 "type":"object",
                 "additionalProperties":{
                    "$ref":"#/components/schemas/LoggingConfigRequest"
                 },
                 "description":"Map from UUIDs to LoggingConfigRequest objects"
              },
              "del_logging_configs":{
                 "type":"array",
                 "items":{
                    "type":"string",
                    "description":"Uuid format string, example - a41152ed-c26e-4c6e-a8d1-8820e36972c3"
                 }
              },
              "pending_subscription_change_request":{
                 "$ref":"#/components/schemas/SubscriptionChangeRequest"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this account is enabled. This may only be changed by sysadmins."
              },
              "subscription":{
                 "$ref":"#/components/schemas/SubscriptionType"
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"Sysadmin-defined metadata for this account. Stored as key-value pairs. This field may only be used by sysadmin users.\n"
              },
              "key_undo_policy":{
                 "$ref":"#/components/schemas/KeyUndoPolicy"
              }
           }
        },
        "KeyUndoPolicy":{
           "required":[
              "undo_time_window"
           ],
           "type":"object",
           "properties":{
              "undo_time_window":{
                 "type":"integer",
                 "description":"The time window in seconds operations can be reverted"
              }
           },
           "description":"A policy to revert operations done inadvertently"
        },
        "AuthConfig":{
           "type":"object",
           "properties":{
              "password":{
                 "$ref":"#/components/schemas/AuthConfigPassword"
              },
              "saml":{
                 "type":"string",
                 "description":"XML metadata for a SAML 2.0 Identity Provider (IdP)."
              },
              "signed_jwt":{
                 "$ref":"#/components/schemas/AuthConfigSignedJWT"
              }
           }
        },
        "AuthConfigPassword":{
           "required":[
              "administrators_only",
              "require_2fa"
           ],
           "type":"object",
           "properties":{
              "require_2fa":{
                 "type":"boolean",
                 "description":"Reserved for future use, must be false."
              },
              "administrators_only":{
                 "type":"boolean",
                 "description":"Reserved for future use, must be false."
              }
           },
           "description":"Configuration for password-based authentication."
        },
        "JWTSigningKeyType":{
           "type":"string",
           "description":"Type of signing key.",
           "enum":[
              "Fetched",
              "Stored"
           ]
        },
        "AuthConfigSignedJWT":{
           "required":[
              "signing_keys",
              "valid_issuers"
           ],
           "type":"object",
           "properties":{
              "valid_issuers":{
                 "type":"array",
                 "description":"An array of valid issuers. JWT presented for authentication must have one of these issuers.",
                 "items":{
                    "type":"string",
                    "description":"A valid issuer."
                 }
              },
              "signing_keys":{
                 "required":[
                    "kind"
                 ],
                 "type":"object",
                 "properties":{
                    "kind":{
                       "$ref":"#/components/schemas/JWTSigningKeyType"
                    },
                    "keys":{
                       "type":"object",
                       "additionalProperties":{
                          "type":"string"
                       },
                       "description":"In case of \"stored\" kind, a map of key ids (arbitrary strings) to base64-encoded DER keys"
                    },
                    "url":{
                       "type":"string",
                       "description":"In case of \"fetched\" kind, URL for fetching public key for verification of JWT signature"
                    },
                    "cache_duration":{
                       "type":"integer",
                       "description":"In case of \"fetched\" kind, duration for which the public key can be cached"
                    }
                 },
                 "description":"Details of signning key that will be used for signature verification."
              }
           },
           "description":"Configuration for signed JWT authentication."
        },
        "UserAccountFlags":{
           "type":"string",
           "description":"Flags for users roles and state for an account.",
           "enum":[
              "AccountAdministrator",
              "AccountMember",
              "AccountAuditor",
              "StateEnabled",
              "PendingInvite"
           ]
        },
        "UserGroupFlags":{
           "type":"string",
           "description":"Flags for users role for a group.",
           "enum":[
              "GroupAdministrator",
              "GroupAuditor"
           ]
        },
        "UserState":{
           "type":"string",
           "description":"State of users.",
           "enum":[
              "PendingConfirmation",
              "Locked",
              "Disabled",
              "Active"
           ]
        },
        "User":{
           "required":[
              "created_at",
              "email_verified",
              "enabled",
              "groups",
              "state",
              "u2f_devices",
              "user_email",
              "user_id"
           ],
           "type":"object",
           "properties":{
              "user_id":{
                 "type":"string",
                 "description":"User ID uniquely identifying this user."
              },
              "user_email":{
                 "type":"string",
                 "description":"The User's email address."
              },
              "state":{
                 "$ref":"#/components/schemas/UserState"
              },
              "account_role":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/UserAccountFlags"
                 }
              },
              "groups":{
                 "$ref":"#/components/schemas/UserGroupMap"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this user's account is enabled."
              },
              "email_verified":{
                 "type":"boolean",
                 "description":"Whether this user's email has been verified."
              },
              "created_at":{
                 "type":"string",
                 "description":"When this user was added to DSM.",
                 "format":"dateTime"
              },
              "last_logged_in_at":{
                 "type":"string",
                 "description":"When this user last logged in.",
                 "format":"dateTime"
              },
              "u2f_devices":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/U2fDevice"
                 }
              }
           }
        },
        "UserRequest":{
           "required":[
              "user_email",
              "user_password"
           ],
           "type":"object",
           "properties":{
              "user_email":{
                 "type":"string",
                 "description":"User's email address."
              },
              "user_password":{
                 "type":"string",
                 "description":"The password to assign to this user in DSM."
              },
              "account_role":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/UserAccountFlags"
                 }
              },
              "add_groups":{
                 "$ref":"#/components/schemas/UserGroupMap"
              },
              "del_groups":{
                 "$ref":"#/components/schemas/UserGroupMap"
              },
              "mod_groups":{
                 "$ref":"#/components/schemas/UserGroupMap"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this application is enabled."
              },
              "add_u2f_devices":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/U2fAddDeviceRequest"
                 }
              },
              "del_u2f_devices":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/U2fDelDeviceRequest"
                 }
              },
              "rename_u2f_devices":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/U2fRenameDeviceRequest"
                 }
              }
           }
        },
        "SignupRequest":{
           "required":[
              "recaptcha_response",
              "user_email",
              "user_password"
           ],
           "type":"object",
           "properties":{
              "user_email":{
                 "type":"string",
                 "description":"User's email address."
              },
              "user_password":{
                 "type":"string",
                 "description":"The password to assign to this user in DSM."
              },
              "first_name":{
                 "type":"string"
              },
              "last_name":{
                 "type":"string"
              },
              "recaptcha_response":{
                 "type":"string"
              }
           }
        },
        "PasswordChangeRequest":{
           "required":[
              "current_password",
              "new_password"
           ],
           "type":"object",
           "properties":{
              "current_password":{
                 "type":"string"
              },
              "new_password":{
                 "type":"string"
              }
           }
        },
        "SelectAccountRequest":{
           "required":[
              "acct_id"
           ],
           "type":"object",
           "properties":{
              "acct_id":{
                 "type":"string",
                 "description":"Uuid format string, example - a41152ed-c26e-4c6e-a8d1-8820e36972c3"
              }
           }
        },
        "SelectAccountResponse":{
           "type":"object",
           "properties":{
              "cookie":{
                 "type":"string"
              }
           }
        },
        "ProcessInviteRequest":{
           "type":"object",
           "properties":{
              "accepts":{
                 "type":"array",
                 "items":{
                    "type":"string",
                    "description":"ID of an invitation to accept."
                 }
              },
              "rejects":{
                 "type":"array",
                 "items":{
                    "type":"string",
                    "description":"ID of an invitation to reject."
                 }
              }
           }
        },
        "ForgotPasswordRequest":{
           "required":[
              "user_email"
           ],
           "type":"object",
           "properties":{
              "user_email":{
                 "type":"string"
              }
           }
        },
        "PasswordResetRequest":{
           "required":[
              "new_password",
              "reset_token"
           ],
           "type":"object",
           "properties":{
              "reset_token":{
                 "type":"string"
              },
              "new_password":{
                 "type":"string"
              }
           }
        },
        "UserAccountMap":{
           "type":"object",
           "additionalProperties":{
              "type":"array",
              "items":{
                 "$ref":"#/components/schemas/UserAccountFlags"
              }
           },
           "description":"A UserAccountMap has keys which are the UUIDs of the accounts that the user belongs to. The value for each key is an array of UserAccountFlags representing the account properties.\n"
        },
        "UserGroupMap":{
           "type":"object",
           "additionalProperties":{
              "type":"array",
              "items":{
                 "$ref":"#/components/schemas/UserGroupFlags"
              }
           },
           "description":"A UserGroupMap has keys which are the UUIDs of the groups that the user belongs to. The value for each key is an array of UserGroupFlags representing the group properties.\n"
        },
        "ValidateTokenRequest":{
           "required":[
              "reset_token"
           ],
           "type":"object",
           "properties":{
              "reset_token":{
                 "type":"string"
              }
           }
        },
        "ValidateTokenResponse":{
           "required":[
              "user_email"
           ],
           "type":"object",
           "properties":{
              "user_email":{
                 "type":"string"
              }
           }
        },
        "AuditLogResponse":{
           "required":[
              "acct_id",
              "action_type",
              "actor_id",
              "actor_type",
              "group_ids",
              "message",
              "object_id",
              "severity",
              "time"
           ],
           "type":"object",
           "properties":{
              "action_type":{
                 "type":"string",
                 "description":"Type of action performed."
              },
              "actor_type":{
                 "type":"string",
                 "description":"Type of entity performing action."
              },
              "message":{
                 "type":"string",
                 "description":"Audit log message."
              },
              "severity":{
                 "type":"string",
                 "description":"Severity of audit log message."
              },
              "time":{
                 "type":"string",
                 "description":"Time that action occurred."
              },
              "object_id":{
                 "type":"string",
                 "description":"ID of object acted upon."
              },
              "actor_id":{
                 "type":"string",
                 "description":"ID of entity performing action."
              },
              "acct_id":{
                 "type":"string",
                 "description":"Account ID of the account this audit log applies to."
              },
              "group_ids":{
                 "type":"array",
                 "items":{
                    "type":"string"
                 }
              }
           }
        },
        "StatsResponse":{
           "type":"object",
           "properties":{
              "time":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"object"
                 }
              }
           }
        },
        "WrapKeyRequest":{
           "required":[
              "alg",
              "kid"
           ],
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "kid":{
                 "type":"string",
                 "description":"The key ID (not name or description) of the key being wrapped."
              },
              "mode":{
                 "$ref":"#/components/schemas/CryptMode"
              },
              "key_format":{
                 "$ref":"#/components/schemas/KeyFormat"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
                 "format":"byte"
              },
              "tag_len":{
                 "type":"integer",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
                 "format":"int32"
              }
           }
        },
        "WrapKeyRequestEx":{
           "required":[
              "alg",
              "key",
              "subject"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "subject":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "mode":{
                 "$ref":"#/components/schemas/CryptMode"
              },
              "key_format":{
                 "$ref":"#/components/schemas/KeyFormat"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers, this value will be used for the cipher initialization value. If not provided, DSM will generate a random iv and return it in the response. If provided, iv length must match the length required by the cipher and mode.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this optionally specifies the authenticated data used by the cipher. This field must not be provided with other cipher modes.\n",
                 "format":"byte"
              },
              "tag_len":{
                 "type":"integer",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, this field specifies the length of the authentication tag to be produced. This field is specified in bits (not bytes). This field is required for symmetric ciphers with cipher mode GCM or CCM. It must not be specified for asymmetric ciphers and symmetric ciphers with other cipher modes.",
                 "format":"int32"
              }
           }
        },
        "WrapKeyResponse":{
           "required":[
              "wrapped_key"
           ],
           "type":"object",
           "properties":{
              "wrapped_key":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The wrapped key.",
                 "format":"byte"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialiation value used for symmetric encryption. Not returned for asymmetric ciphers.",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"For symmetric ciphers with cipher mode GCM or CCM, the authentication tag produced by the cipher. Its length will match the tag length specified by the encryption request.\n",
                 "format":"byte"
              }
           }
        },
        "UnwrapKeyRequest":{
           "required":[
              "alg",
              "name",
              "obj_type",
              "wrapped_key"
           ],
           "type":"object",
           "properties":{
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.\n"
              },
              "obj_type":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "wrapped_key":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"A Security Object previously wrapped with another key.\n",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/CryptMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              },
              "name":{
                 "type":"string",
                 "description":"Name of the security object to unwrap. Security object names must be unique within an account."
              },
              "description":{
                 "type":"string",
                 "description":"Description of the Security object to unwrap."
              },
              "key_ops":{
                 "type":"array",
                 "description":"Optional array of key operations to be enabled for this security object. If this property is not provided, the DSM server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"User-defined metadata for this key. Stored as key-value pairs."
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether the new security object should be enabled. Disabled security objects may not perform cryptographic operations.\n"
              },
              "transient":{
                 "type":"boolean",
                 "description":"If this is true, DSM will unwrap a transient key."
              },
              "rsa":{
                 "$ref":"#/components/schemas/RsaOptions"
              }
           }
        },
        "UnwrapKeyRequestEx":{
           "required":[
              "alg",
              "key",
              "name",
              "obj_type",
              "wrapped_key"
           ],
           "type":"object",
           "properties":{
              "key":{
                 "$ref":"#/components/schemas/SobjectDescriptor"
              },
              "alg":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "group_id":{
                 "type":"string",
                 "description":"Group ID (not name) of the security group that this security object should belong to. The user or application creating this security object must be a member of this group. If no group is specified, the default group for the user or application will be used.\n"
              },
              "obj_type":{
                 "$ref":"#/components/schemas/ObjectType"
              },
              "wrapped_key":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"A Security Object previously wrapped with another key.\n",
                 "format":"byte"
              },
              "mode":{
                 "$ref":"#/components/schemas/CryptMode"
              },
              "iv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The initialization value used to encrypt this ciphertext. This field is required for symmetric ciphers, and ignored for asymmetric ciphers.\n",
                 "format":"byte"
              },
              "ad":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authenticated data used with this ciphertext and authentication tag. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              },
              "tag":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"The authentication tag used with this ciphertext and authenticated data. This field is required for symmetric ciphers using cipher mode GCM or CCM, and must not be specified for all other ciphers.\n",
                 "format":"byte"
              },
              "name":{
                 "type":"string",
                 "description":"Name of the security object to unwrap. Security object names must be unique within an account."
              },
              "description":{
                 "type":"string",
                 "description":"Description of the Security object to unwrap."
              },
              "key_ops":{
                 "type":"array",
                 "description":"Optional array of key operations to be enabled for this security object. If this property is not provided, the DSM server will provide a default set of key operations. Note that if you provide an empty array, all key operations will be disabled.\n",
                 "items":{
                    "$ref":"#/components/schemas/KeyOperations"
                 }
              },
              "custom_metadata":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"User-defined metadata for this key. Stored as key-value pairs."
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether the new security object should be enabled. Disabled security objects may not perform cryptographic operations.\n"
              },
              "rsa":{
                 "$ref":"#/components/schemas/RsaOptions"
              }
           }
        },
        "MfaChallenge":{
           "required":[
              "u2f_challenge",
              "u2f_keys"
           ],
           "type":"object",
           "properties":{
              "u2f_challenge":{
                 "type":"string"
              },
              "u2f_keys":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/U2fKey"
                 }
              }
           },
           "description":"Challenge for registring or authenticating with a U2F two factor device."
        },
        "U2fKey":{
           "required":[
              "keyHandle",
              "version"
           ],
           "type":"object",
           "properties":{
              "keyHandle":{
                 "type":"string"
              },
              "version":{
                 "type":"string"
              }
           },
           "description":"A U2F key that may be used for two factor authentication."
        },
        "RecoveryCodes":{
           "required":[
              "recovery_codes"
           ],
           "type":"object",
           "properties":{
              "recovery_codes":{
                 "type":"array",
                 "items":{
                    "type":"string"
                 }
              }
           },
           "description":"Backup recovery codes for two factor authentication."
        },
        "U2fDevice":{
           "required":[
              "name"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string"
              }
           },
           "description":"A U2f device that may be used for second factor authentication."
        },
        "U2fAddDeviceRequest":{
           "required":[
              "clientData",
              "name",
              "registrationData",
              "version"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string"
              },
              "registrationData":{
                 "type":"string"
              },
              "clientData":{
                 "type":"string"
              },
              "version":{
                 "type":"string"
              }
           },
           "description":"Description of a U2F device to add for two factor authentication."
        },
        "U2fDelDeviceRequest":{
           "required":[
              "name"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string"
              }
           },
           "description":"Request to delete a U2F device."
        },
        "U2fRenameDeviceRequest":{
           "required":[
              "new_name",
              "old_name"
           ],
           "type":"object",
           "properties":{
              "old_name":{
                 "type":"string"
              },
              "new_name":{
                 "type":"string"
              }
           },
           "description":"Request to rename a U2F device."
        },
        "ServerMode":{
           "type":"string",
           "description":"Server mode.",
           "enum":[
              "Software",
              "Sgx"
           ]
        },
        "VersionResponse":{
           "required":[
              "api_version",
              "server_mode",
              "version"
           ],
           "type":"object",
           "properties":{
              "version":{
                 "type":"string",
                 "description":"The DSM server version. This is encoded as major.minor.build. For example, 1.0.25.\n"
              },
              "api_version":{
                 "type":"string",
                 "description":"The API version implemented by this server."
              },
              "server_mode":{
                 "$ref":"#/components/schemas/ServerMode"
              },
              "fips_level":{
                 "type":"integer",
                 "description":"FIPS level at which DSM in running. If this field is absent, then DSM is not running in FIPS compliant mode."
              }
           }
        },
        "PluginType":{
           "type":"string",
           "description":"Type of this plugin.",
           "enum":[
              "Standard",
              "Impersonating",
              "CustomAlgorithm"
           ]
        },
        "Language":{
           "type":"string",
           "description":"Language for plugin code.",
           "enum":[
              "Lua"
           ]
        },
        "PluginSource":{
           "required":[
              "code",
              "language"
           ],
           "type":"object",
           "properties":{
              "language":{
                 "$ref":"#/components/schemas/Language"
              },
              "code":{
                 "type":"string"
              }
           },
           "description":"Plugin code that will be executed in DSM."
        },
        "Plugin":{
           "required":[
              "acct_id",
              "created_at",
              "creator",
              "default_group",
              "enabled",
              "groups",
              "lastrun_at",
              "lastupdated_at",
              "name",
              "plugin_id",
              "plugin_type",
              "source"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the plugin. Plugin names must be unique within an account."
              },
              "plugin_id":{
                 "type":"string",
                 "description":"Plugin ID uniquely identifying this plugin."
              },
              "description":{
                 "type":"string",
                 "description":"Description of this plugin."
              },
              "acct_id":{
                 "type":"string",
                 "description":"The account ID of the account that this plugin belongs to."
              },
              "groups":{
                 "type":"array",
                 "description":"An array of security group IDs. The plugin belongs to each Security Group in this array.",
                 "items":{
                    "type":"string",
                    "description":"A group ID (not name or description)."
                 }
              },
              "default_group":{
                 "type":"string",
                 "description":"The default group of this plugin. This is the group where security objects will be created by default by this plugin."
              },
              "source":{
                 "$ref":"#/components/schemas/PluginSource"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this plugin is enabled."
              },
              "plugin_type":{
                 "$ref":"#/components/schemas/PluginType"
              },
              "creator":{
                 "$ref":"#/components/schemas/CreatorType"
              },
              "created_at":{
                 "type":"string",
                 "description":"When this plugin was created.",
                 "format":"dateTime"
              },
              "lastrun_at":{
                 "type":"string",
                 "description":"When this plugin was last run.",
                 "format":"dateTime"
              },
              "lastupdated_at":{
                 "type":"string",
                 "description":"When this plugin was last updated.",
                 "format":"dateTime"
              }
           }
        },
        "PluginRequest":{
           "required":[
              "add_groups",
              "default_group",
              "name",
              "source"
           ],
           "type":"object",
           "properties":{
              "name":{
                 "type":"string",
                 "description":"Name of the plugin. Plugin names must be unique within an account."
              },
              "description":{
                 "type":"string",
                 "description":"Description of this plugin."
              },
              "add_groups":{
                 "type":"array",
                 "description":"An array of Security Group IDs to add to this plugin.",
                 "items":{
                    "type":"string",
                    "description":"A group ID (not name or description)."
                 }
              },
              "del_groups":{
                 "type":"array",
                 "description":"An array of security group IDs to remove from this plugin.",
                 "items":{
                    "type":"string",
                    "description":"A group ID (not name or description)."
                 }
              },
              "default_group":{
                 "type":"string",
                 "description":"The default group of this plugin. This is the group where security objects will be created by default by this plugin."
              },
              "source":{
                 "$ref":"#/components/schemas/PluginSource"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this plugin is enabled."
              },
              "plugin_type":{
                 "$ref":"#/components/schemas/PluginType"
              }
           }
        },
        "PluginInvokeRequest":{
           "type":"object",
           "x-arbitrary-model":true
        },
        "PluginInvokeResponse":{
           "type":"object",
           "x-arbitrary-model":true
        },
        "ConfirmEmailRequest":{
           "required":[
              "confirm_token"
           ],
           "type":"object",
           "properties":{
              "confirm_token":{
                 "type":"string"
              }
           }
        },
        "ConfirmEmailResponse":{
           "required":[
              "user_email"
           ],
           "type":"object",
           "properties":{
              "user_email":{
                 "type":"string"
              }
           }
        },
        "SplunkLoggingConfig":{
           "required":[
              "enabled",
              "host",
              "index",
              "port",
              "tls"
           ],
           "type":"object",
           "properties":{
              "host":{
                 "type":"string"
              },
              "port":{
                 "type":"integer"
              },
              "index":{
                 "type":"string",
                 "description":"The Splunk index that will receive log items"
              },
              "tls":{
                 "$ref":"#/components/schemas/TlsConfig"
              },
              "enabled":{
                 "type":"boolean"
              }
           }
        },
        "SplunkLoggingConfigRequest":{
           "type":"object",
           "properties":{
              "host":{
                 "type":"string"
              },
              "port":{
                 "type":"integer"
              },
              "index":{
                 "type":"string",
                 "description":"The Splunk index that will receive log items"
              },
              "token":{
                 "type":"string",
                 "description":"The Splunk authentication token"
              },
              "tls":{
                 "$ref":"#/components/schemas/TlsConfig"
              },
              "enabled":{
                 "type":"boolean"
              }
           }
        },
        "StackdriverLoggingConfig":{
           "required":[
              "enabled",
              "log_id",
              "service_account_key"
           ],
           "type":"object",
           "properties":{
              "log_id":{
                 "type":"string",
                 "description":"The log ID that will recieve the log items (see https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry)."
              },
              "service_account_key":{
                 "$ref":"#/components/schemas/GoogleServiceAccountKey"
              },
              "enabled":{
                 "type":"boolean"
              }
           }
        },
        "StackdriverLoggingConfigRequest":{
           "type":"object",
           "properties":{
              "log_id":{
                 "type":"string",
                 "description":"The log ID that will recieve the log items (see https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry)."
              },
              "service_account_key":{
                 "$ref":"#/components/schemas/GoogleServiceAccountKey"
              },
              "enabled":{
                 "type":"boolean"
              }
           }
        },
        "GoogleServiceAccountKey":{
           "required":[
              "client_email",
              "private_key_id",
              "project_id",
              "type"
           ],
           "type":"object",
           "properties":{
              "type":{
                 "type":"string",
                 "description":"Must be \"service_account\""
              },
              "project_id":{
                 "type":"string"
              },
              "private_key_id":{
                 "type":"string"
              },
              "private_key":{
                 "type":"string"
              },
              "client_email":{
                 "type":"string"
              }
           },
           "description":"A Google service account key object. See https://cloud.google.com/video-intelligence/docs/common/auth."
        },
        "LoggingConfig":{
           "type":"object",
           "properties":{
              "splunk":{
                 "$ref":"#/components/schemas/SplunkLoggingConfig"
              },
              "stackdriver":{
                 "$ref":"#/components/schemas/StackdriverLoggingConfig"
              }
           }
        },
        "LoggingConfigRequest":{
           "type":"object",
           "properties":{
              "splunk":{
                 "$ref":"#/components/schemas/SplunkLoggingConfigRequest"
              },
              "stackdriver":{
                 "$ref":"#/components/schemas/StackdriverLoggingConfigRequest"
              }
           }
        },
        "TlsMode":{
           "type":"string",
           "description":"TLS mod.",
           "default":"disabled",
           "enum":[
              "disabled",
              "opportunistic",
              "required"
           ]
        },
        "CaConfig":{
           "type":"object",
           "properties":{
              "ca_set":{
                 "type":"string",
                 "default":"global_roots",
                 "enum":[
                    "global_roots"
                 ]
              },
              "pinned":{
                 "type":"array",
                 "items":{
                    "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type":"string",
                    "format":"byte"
                 }
              }
           }
        },
        "TlsConfig":{
           "required":[
              "mode"
           ],
           "type":"object",
           "properties":{
              "mode":{
                 "$ref":"#/components/schemas/TlsMode"
              },
              "validate_hostname":{
                 "type":"boolean"
              },
              "ca":{
                 "$ref":"#/components/schemas/CaConfig"
              }
           }
        },
        "RsaOptions":{
           "type":"object",
           "properties":{
              "key_size":{
                 "type":"integer",
                 "description":"Specify on Create only. Returned on Get. Size in bits (not bytes) of the RSA key.",
                 "format":"int32"
              },
              "public_exponent":{
                 "type":"integer",
                 "description":"Specify on Create only. Public exponent to use for generating the RSA key.",
                 "format":"int32"
              },
              "encryption_policy":{
                 "type":"array",
                 "description":"Encryption policy for this RSA key. When doing an encryption or key wrapping operation, the policies are evaluated against the specified parameters one by one. If one matches, the operation is allowed. If none match, including if the policy list is empty, the operation is disallowed. Missing optional parameters will have their defaults specified according to the matched policy. The default for new keys is `[{\"padding\":{\"OAEP\":{}}]`. If (part of) a constraint is not specified, anything is allowed for that constraint. To impose no constraints, specify `[{}]`.\n",
                 "items":{
                    "$ref":"#/components/schemas/RsaEncryptionPolicy"
                 }
              },
              "signature_policy":{
                 "type":"array",
                 "description":"Signature policy for this RSA key. When doing a signature operation, the policies are evaluated against the specified parameters one by one. If one matches, the operation is allowed. If none match, including if the policy list is empty, the operation is disallowed. Missing optional parameters will have their defaults specified according to the matched policy. The default for new keys is `[{}]` (no constraints). If (part of) a constraint is not specified, anything is allowed for that constraint.\n",
                 "items":{
                    "$ref":"#/components/schemas/RsaSignaturePolicy"
                 }
              }
           },
           "description":"RSA-specific options."
        },
        "DsaOptions":{
           "type":"object",
           "properties":{
              "subgroup_size":{
                 "type":"integer",
                 "description":"Specify on Create only. Returned on Get. Size in bits (not bytes) of the DSA subgroup. When `key_size` = 2048, allowed values are 224 or 256. When `key_size` = 3072, allowed value is 256.",
                 "format":"int32"
              }
           },
           "description":"DSA-specific options."
        },
        "RsaEncryptionPolicy":{
           "type":"object",
           "properties":{
              "padding":{
                 "type":"object",
                 "properties":{
                    "PKCS1_V15":{
                       "type":"object",
                       "properties":{
                          
                       }
                    },
                    "OAEP":{
                       "type":"object",
                       "properties":{
                          "mgf":{
                             "$ref":"#/components/schemas/Mgf"
                          }
                       }
                    }
                 }
              }
           },
           "description":"Constraints on RSA encryption parameters. In general, if a constraint is not specified, anything is allowed."
        },
        "RsaSignaturePolicy":{
           "type":"object",
           "properties":{
              "padding":{
                 "type":"object",
                 "properties":{
                    "PKCS1_V15":{
                       "type":"object",
                       "properties":{
                          
                       }
                    },
                    "PSS":{
                       "type":"object",
                       "properties":{
                          "mgf":{
                             "$ref":"#/components/schemas/Mgf"
                          }
                       }
                    }
                 }
              }
           },
           "description":"Constraints on RSA signature parameters. In general, if a constraint is not specified, anything is allowed."
        },
        "ApprovalRequest":{
           "required":[
              "acct_id",
              "approvers",
              "body",
              "created_at",
              "denier",
              "expiry",
              "method",
              "operation",
              "request_id",
              "requester",
              "reviewers",
              "status",
              "subjects"
           ],
           "type":"object",
           "properties":{
              "request_id":{
                 "type":"string",
                 "description":"UUID uniquely identifying this approval request."
              },
              "requester":{
                 "$ref":"#/components/schemas/Entity"
              },
              "created_at":{
                 "type":"string",
                 "description":"When this approval request was created.",
                 "format":"dateTime"
              },
              "acct_id":{
                 "type":"string",
                 "description":"The account ID of the account that this approval request belongs to."
              },
              "operation":{
                 "type":"string",
                 "description":"Operation URL path, e.g. `/crypto/v1/keys`, `/crypto/v1/groups/<id>`."
              },
              "method":{
                 "type":"string",
                 "description":"Method for the operation: POST, PATCH, PUT, DELETE, or GET. Default is POST.\n"
              },
              "body":{
                 "type":"object",
                 "properties":{
                    
                 },
                 "x-arbitrary-model":true
              },
              "approvers":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/Entity"
                 }
              },
              "denier":{
                 "$ref":"#/components/schemas/Entity"
              },
              "status":{
                 "$ref":"#/components/schemas/ApprovalStatus"
              },
              "reviewers":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/Entity"
                 }
              },
              "subjects":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/ApprovalSubject"
                 }
              },
              "description":{
                 "type":"string",
                 "description":"Optional comment about the approval request for the reviewer."
              },
              "expiry":{
                 "type":"string",
                 "description":"When this approval request expires.",
                 "format":"dateTime"
              }
           }
        },
        "ApprovalRequestRequest":{
           "required":[
              "operation"
           ],
           "type":"object",
           "properties":{
              "operation":{
                 "type":"string",
                 "description":"Operation URL path, e.g. `/crypto/v1/keys`, `/crypto/v1/groups/<id>`."
              },
              "method":{
                 "type":"string",
                 "description":"Method for the operation: POST, PATCH, PUT, DELETE, or GET. Default is POST.\n"
              },
              "body":{
                 "type":"object",
                 "properties":{
                    
                 },
                 "x-arbitrary-model":true
              },
              "description":{
                 "type":"string",
                 "description":"Optional comment about the approval request for the reviewer."
              }
           }
        },
        "ApprovableResult":{
           "required":[
              "body",
              "status"
           ],
           "type":"object",
           "properties":{
              "status":{
                 "type":"integer",
                 "description":"The HTTP status code for this partial request."
              },
              "body":{
                 "type":"object",
                 "properties":{
                    
                 },
                 "x-arbitrary-model":true
              }
           }
        },
        "ApprovalStatus":{
           "type":"string",
           "description":"Approval request status.",
           "enum":[
              "PENDING",
              "APPROVED",
              "DENIED",
              "FAILED"
           ]
        },
        "ApprovalSubject":{
           "type":"object",
           "properties":{
              "group":{
                 "type":"string",
                 "description":"The ID of the group being acted upon, if the subject is a group."
              },
              "sobject":{
                 "type":"string",
                 "description":"The ID of the security object being acted upon, if the subject is a security object."
              },
              "app":{
                 "type":"string",
                 "description":"The ID of the app being acted upon, if the subject is a app."
              },
              "plugin":{
                 "type":"string",
                 "description":"The ID of the plugin being acted upon, if the subject is a app."
              }
           },
           "description":"Identifies an object acted upon by an approval request."
        },
        "Entity":{
           "type":"object",
           "properties":{
              "app":{
                 "type":"string",
                 "description":"The application ID of the application that created this entity, if this entity was created by an application."
              },
              "user":{
                 "type":"string",
                 "description":"The user ID of the user who created this entity, if this entity was created by a user."
              },
              "plugin":{
                 "type":"string",
                 "description":"The plugin ID of the user who created this entity, if this entity was created by a plugin."
              }
           },
           "description":"An app, user, or plugin ID."
        },
        "FpeOptions":{
           "type":"object",
           "description":"FPE-specific options. Either of type `FpeOptionsBasic` or `FpeOptionsAdvanced`, but not both."
        },
        "FpeOptionsBasic":{
           "required":[
              "radix"
           ],
           "type":"object",
           "properties":{
              "radix":{
                 "type":"integer",
                 "description":"The base for input data. The radix should be a number from 2 to 36, inclusive. Each radix corresponds to a subset of ASCII alphanumeric characters (with all letters being uppercase). For instance, a radix of 10 corresponds to a character set consisting of the digits from 0 to 9, while a character set of 16 corresponds to a character set consisting of all hexadecimal digits (with letters A-F being uppercase).\n",
                 "format":"int32"
              },
              "min_length":{
                 "type":"integer",
                 "description":"The minimum allowed length for the input data. If not specified, as a default, the min length will be set to the smallest value that allows the condition radix^min_length >= 100 to be satisfied.",
                 "format":"int32"
              },
              "max_length":{
                 "type":"integer",
                 "description":"The maximum allowed length for the input data. If not specified, a default max length of 2^16 will be used.",
                 "format":"int32"
              },
              "preserve":{
                 "type":"array",
                 "description":"The list of indices of characters to be preserved while performing encryption/decryption. Indices are Python-like, where negative indices index from the back of the token, with -1 referring to the end of the token. It is an error to specify indices greater than (min_length - 1) or less than (-min_length).\n",
                 "items":{
                    "type":"integer",
                    "description":"An index of character to be preserved while performing encryption/decryption.",
                    "format":"int32"
                 }
              },
              "mask":{
                 "type":"array",
                 "description":"The list of indices of characters to be masked while performing masked decryption. Indices are Python-like, where negative indices index from the back of the token, with -1 referring to the end of the token. It is an error to specify indices greater than (min_length - 1) or less than (-min_length).\n",
                 "items":{
                    "type":"integer",
                    "description":"An index of character to be masked while performing masked decryption.",
                    "format":"int32"
                 }
              },
              "luhn_check":{
                 "type":"boolean",
                 "description":"Whether encrypted/decrypted data should satisfy LUHN checksum formula."
              },
              "name":{
                 "type":"string",
                 "description":"The user-friendly name for the data type that represents the input data."
              }
           },
           "description":"Basic FPE-specific options."
        },
        "FpeOptionsAdvanced":{
           "required":[
              "format"
           ],
           "type":"object",
           "properties":{
              "format":{
                 "$ref":"#/components/schemas/FpeDataPart"
              },
              "description":{
                 "type":"string",
                 "description":"The user-friendly name for the data type that represents the input data."
              },
              "name":{
                 "type":"string",
                 "description":"A duplicate of the `description` field. This field is read-only and cannot be assigned. Thus, when specifying a new `SobjectRequest`, this field should not be used.\n"
              }
           },
           "description":"Information about a complex tokenization data type."
        },
        "FpeDataPart":{
           "type":"object",
           "description":"Structure for specifying (part of) a complex tokenization data type, which must be either an `FpeEncryptedPart`, `FpeLiteralPart`, or an `FpeCompoundPart`.\n\n***Implementation note: the current parser is locally \"greedy\" and does not backtrack if it happens to construct an invalid parse of an input token. The general idea here is that if a section of an input token can be parsed multiple ways, currently, the parser will \"greedily\" pick the first choice that matches, and, if that choice turns out to be problematic, will not go back and consider other choices. (Exactly what the \"first choice\" is depends on the type of the `FpeDataPart`; this is described in further detail in the descriptions of the three `FpeDataPart` variants.)***\n"
        },
        "FpeEncryptedPart":{
           "required":[
              "char_set",
              "max_length",
              "min_length"
           ],
           "type":"object",
           "properties":{
              "min_length":{
                 "type":"integer",
                 "description":"The minimum allowed length for this part (in chars).",
                 "format":"int32"
              },
              "max_length":{
                 "type":"integer",
                 "description":"The maximum allowed length for this part (in chars).",
                 "format":"int32"
              },
              "char_set":{
                 "type":"array",
                 "description":"The character set to use for this part.\n\nCharacters should be specified as a list of pairs, where each pair [a, b] (example: ['0', '9']) represents the range of Unicode codepoints from a to b, with both bounds being inclusive. A single character can be represented as [c, c] (example: ['/', '/']).\n\nRanges should not overlap with each other, and should not contain surrogate codepoints.\n\n*Implementation note: normally, each character is assigned a numeric value for FF1, going in the order specified in the array. For instance, in the character set [['a', 'z'], ['0', '9']], the digits from 0 to 9 DO NOT have their usual numeric values; instead, they correspond to the numerals from 26 to 35 (since they come after the 'a' to 'z' range). Note that for practical purposes, this is largely irrelevant, except when specifying a \"numeric\" character set, which MUST contain exactly the digits from 0 to 9, in order. **(When trying to use numeric constraints, it is best to use [[\"0\", \"9\"]] as the character set.)***\n",
                 "items":{
                    "type":"array",
                    "description":"A Unicode character range in the form [a, b], where the codepoint for character a does not come after the codepoint for character b. Ranges should not contain surrogate codepoints.\n",
                    "items":{
                       "type":"string"
                    }
                 }
              },
              "constraints":{
                 "$ref":"#/components/schemas/FpeConstraints"
              },
              "preserve":{
                 "type":"object",
                 "description":"The characters to be preserved while encrypting or decrypting. This should either be the string \"all\", or it should be an array of Python-like indices (i.e., where negative indices index from the back of the token portion, with -1 referring to the end of the array). When specifying indices, it is an error to specify indices greater than (min_length - 1) or less than (-min_length).\n"
              },
              "mask":{
                 "type":"object",
                 "description":"The characters to be masked while performing masked decryption. This should either be the string \"all\", or it should be an array of Python-like indices (i.e., where negative indices index from the back of the token portion, with -1 referring to the end of the array). When specifying indices, it is an error to specify indices greater than (min_length - 1) or less than (-min_length).\n"
              }
           },
           "description":"Structure of a simple tokenized portion of a complex tokenization data type.\n\n***Implementation note: the parser will try to (locally) match as many characters as possible. (See the description of `FpeDataPart` for more information about why this matters.)***\n"
        },
        "FpeLiteralPart":{
           "required":[
              "literal"
           ],
           "type":"object",
           "properties":{
              "literal":{
                 "type":"array",
                 "description":"The list of possible strings that make up this literal portion of the token.\n\n***Implementation note: the order of the strings matters, as the parser will pick the first string that matches. (See the description of `FpeDataPart` for more information about why this matters.)***\n",
                 "items":{
                    "type":"string"
                 }
              }
           },
           "description":"A literal section of a complex tokenization data type, such as a delimiter.\n"
        },
        "FpeCompoundPart":{
           "type":"object",
           "properties":{
              "or":{
                 "type":"array",
                 "description":"Represents an OR of multiple structures. This cannot be specified alongside the `concat` or `multiple` fields.\n\n***Implementation note: the order of the choices matters, as the parser will pick the first structure that matches. (The parser is locally \"greedy\"; see the description of `FpeDataPart` for more information about why this matters.)***\n",
                 "items":{
                    "$ref":"#/components/schemas/FpeDataPart"
                 }
              },
              "concat":{
                 "type":"array",
                 "description":"Represents a concatentation of multiple structures (in a particular order). This cannot be specified alongside the `or` or `multiple` fields.\n",
                 "items":{
                    "$ref":"#/components/schemas/FpeDataPart"
                 }
              },
              "multiple":{
                 "$ref":"#/components/schemas/FpeDataPart"
              },
              "min_repetitions":{
                 "type":"integer",
                 "description":"The minimum number of times the subpart can be repeated. This field should only be used if the `multiple` field is being used."
              },
              "max_repetitions":{
                 "type":"integer",
                 "description":"The maximum number of times the subpart can be repeated. This field should only be used if the `multiple` field is being used."
              },
              "constraints":{
                 "$ref":"#/components/schemas/FpeConstraints"
              },
              "preserve":{
                 "type":"boolean",
                 "description":"Whether the entire part should be preserved as-is (i.e., not tokenized). If this is set, any descendant subparts cannot contain any preserve-related fields set.\n"
              },
              "mask":{
                 "type":"boolean",
                 "description":"Whether the entire part should be masked when doing masked decryption. If this is set, any descendant subparts cannot contain any mask-related fields set.\n"
              },
              "min_length":{
                 "type":"integer",
                 "description":"The minimum allowed length for this part (in chars).",
                 "format":"int32"
              },
              "max_length":{
                 "type":"integer",
                 "description":"The minimum allowed length for this part (in chars).",
                 "format":"int32"
              }
           },
           "description":"Structure of a compound portion of a complex tokenization data type, itself composed of smaller parts. Note that there are three variants here:\n - Or -- representing an OR of multiple structures\n - Concat -- representing a concatenation of multiple structures\n - Multiple -- representing a part possibly repeated multiple times, where the part to be repeated is under the `multiple` field\n\nThese three variants correspond to the `or`, `concat`, and `multiple` fields, respectively; one of these fields must be specified. It is an error to try to specify more than one variant (e.g., having both an `or` and a `concat` field).\n\n***Implementation note: for Or variants, the parser will go in the order of the choices (see description of the `or` field below), and for Multiple variants, the parser will try to (locally) match as many repetitions as possible. (See the description of `FpeDataPart` for more information about why this matters.)***\n"
        },
        "FpeConstraints":{
           "type":"object",
           "properties":{
              "luhn_check":{
                 "type":"boolean",
                 "description":"Whether the token should satisfy the Luhn checksum. It is an error to apply this constraint to non-numeric parts, or for an encrypted part to be under more than one Luhn check constraint. Also, if an encrypted part has a Luhn check constraint applied to it and may contain at least one digit that is not preserved, it must not specify any other constraints.\n"
              },
              "num_gt":{
                 "type":"integer",
                 "description":"Number that the token part should be greater than. This constraint can only be specified on (non-compound) numeric encrypted parts that are guaranteed to preserve either everything or nothing at all.\n"
              },
              "num_lt":{
                 "type":"integer",
                 "description":"Number that the token part should be smaller than. This constraint can only be specified on (non-compound) numeric encrypted parts that are guaranteed to preserve either everything or nothing at all.\n"
              },
              "num_ne":{
                 "type":"integer",
                 "description":"Numbers that the token part should not be equal to. It is an error to apply this constraint to non-numeric parts."
              },
              "date":{
                 "type":"object",
                 "description":"Specifies that this portion is supposed to represent a date, or part of one. If used, no other constraints can be specified on this part. This field should either be an `FpeDate` object or an `FpeDatePart` value.\n"
              },
              "applies_to":{
                 "type":"object",
                 "description":"The subparts to apply the constraints to. If not specified, the constraints will be applied to all subparts (recursively). (This can also be explictly indicated by specifying the string \"all\"). If only certain subparts are to be specified, then they should be specified as an `FpeConstraintsApplicabilitySubparts` object.\n"
              }
           },
           "description":"Constraints on a portion of a complex tokenization data type."
        },
        "FpeConstraintsApplicabilitySubparts":{
           "type":"object",
           "description":"An object representing the individual subparts that the constraints should apply to. This is an object where for each key-value pair, the key represents the (zero-based) \"index\" of the subpart, and the value is either \"all\" or another `FpeConstraintsApplicabilitySubparts` instance. Note that a Multiple part only allows for one possible key-value pair, due to it containing only one subpart.\n\nThis cannot be used with OR parts; instead, specify constraints individually on each relevant subpart.\n"
        },
        "FpeDatePart":{
           "type":"string",
           "description":"Possible date-related constraint types that do not form a complete date (by themselves) for a complex tokenization data type. The part should be a numeric encrypted part that is guaranteed to either preserve all of its digits or preserve none of them, and cannot be involved in any Luhn-check constraints.\n\nDay and Month parts must have their `min_length` fields be at least 1 and their `max_length` field be exactly 2. Additionally, any leading zeros should be removed (unless required due to length restrictions). Year parts must be two to five digits long.\n",
           "enum":[
              "month",
              "day",
              "year"
           ]
        },
        "FpeDate":{
           "type":"object",
           "properties":{
              "dmy_date":{
                 "$ref":"#/components/schemas/FpeDateWithBounds"
              },
              "month_day_date":{
                 "$ref":"#/components/schemas/FpeDateWithBounds"
              },
              "month_year_date":{
                 "$ref":"#/components/schemas/FpeDateWithBounds"
              }
           },
           "description":"A structure for indicating that a token part represents a date. The part should be a concatenation that matches one of the three variants below:\n - DayMonthYear date -- contains a Day part and a Month part; this corresponds with the `dmy_date` field\n - MonthYear date -- contains a Month part and a Year part; this corresponds with the `month_day_date` field\n - MonthDay date -- contains a Day part, a Month part, and a Year part; this corresponds with the `month_year_date` field\n\n(with this constraint applying to those subparts). Notice how each variant above corresponds with a particular field; using the wrong field, or multiple fields, is an error. The individual Month, Day, and/or Year parts that comprise the date cannot appear under Or or the Multiple compound part descendants of the overall Date part (i.e., when applying the date constraint, the \"paths\" from the Date part to the Month, Day, and/or Year parts can only \"go through\" concatenations, and not \"through\" Or or Multiple parts). Those parts also have additional restrictions on how they may be preserved; the exact rules are as such:\n - A DayMonthYear date may preserve its Year part, and may preserve both its Month and Day parts at the same time. (The Day\n   part cannot be preserved if the Month part is not, and vice versa.)\n - A MonthDay date cannot preserve only its Month part or only its Day part.\n - A MonthYear date may preserve its Year part, but cannot preserve its Month part by itself.\n\n\nIt is an error to \"share\" Day, Month, or Year parts across multiple dates.\n"
        },
        "FpeDateWithBounds":{
           "type":"object",
           "properties":{
              "before":{
                 "$ref":"#/components/schemas/FpeDateBound"
              },
              "after":{
                 "$ref":"#/components/schemas/FpeDateBound"
              }
           },
           "description":"A structure for specifying a date constraint, optionally bounded above (the `before` field) and/or below (the `after` field). All bounds are exclusive.\n"
        },
        "FpeDateBound":{
           "required":[
              "month"
           ],
           "type":"object",
           "properties":{
              "year":{
                 "maximum":99999,
                 "minimum":0,
                 "type":"integer",
                 "description":"The year, which should be a number less than 100000. Zero is treated as a leap year."
              },
              "month":{
                 "maximum":12,
                 "minimum":1,
                 "type":"integer",
                 "description":"The month, which should be a number from 1 to 12."
              },
              "day":{
                 "maximum":31,
                 "minimum":1,
                 "type":"integer",
                 "description":"The day, which should be a number from 1 to 31, and must not be out-of-range for the given month. February is considered to be 29 days long, unless the year, if specified, is not a leap year.\n"
              }
           },
           "description":"A structure for specifying a particular date, used as an upper or lower bound for date parts. Note that depending on the `FpeDate` variant used, the `day` or `year` fields may be ignored. (For example, a Day-Month date would not require a `year` field, so specifying a year in a Day-Month date's upper bound is meaningless.)\n"
        },
        "ChildAccountUser":{
           "required":[
              "groups",
              "user_email",
              "user_id"
           ],
           "type":"object",
           "properties":{
              "user_id":{
                 "type":"string",
                 "description":"User ID uniquely identifying this user."
              },
              "user_email":{
                 "type":"string",
                 "description":"The User's email address."
              },
              "account_role":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/UserAccountFlags"
                 }
              },
              "groups":{
                 "$ref":"#/components/schemas/UserGroupMap"
              },
              "created_at":{
                 "type":"string",
                 "description":"When this user was added to account.",
                 "format":"dateTime"
              },
              "last_logged_in_at":{
                 "type":"string",
                 "description":"When this user last logged in.",
                 "format":"dateTime"
              }
           }
        },
        "ChildAccountUserRequest":{
           "required":[
              "child_acct_id",
              "user_email"
           ],
           "type":"object",
           "properties":{
              "child_acct_id":{
                 "type":"string",
                 "description":"Account id of child account"
              },
              "user_email":{
                 "type":"string",
                 "description":"User's email address."
              },
              "account_role":{
                 "type":"array",
                 "items":{
                    "$ref":"#/components/schemas/UserAccountFlags"
                 }
              },
              "add_groups":{
                 "$ref":"#/components/schemas/UserGroupMap"
              },
              "del_groups":{
                 "$ref":"#/components/schemas/UserGroupMap"
              },
              "mod_groups":{
                 "$ref":"#/components/schemas/UserGroupMap"
              },
              "enabled":{
                 "type":"boolean",
                 "description":"Whether this application is enabled."
              }
           }
        },
        "ApproveRequest":{
           "type":"object",
           "properties":{
              "additionalProperties":{
                 "type":"object"
              }
           }
        },
        "KeyCheckValueResponse":{
           "type":"object",
           "properties":{
              "kid":{
                 "type":"string",
                 "description":"kid of a Security Object"
              },
              "kcv":{
                 "pattern":"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                 "type":"string",
                 "description":"KVC of a Security Object",
                 "format":"byte"
              }
           }
        },
        "HmgConfig":{
           "required":[
              "kind",
              "tls",
              "url"
           ],
           "type":"object",
           "properties":{
              "kind":{
                 "$ref":"#/components/schemas/HmgKind"
              },
              "url":{
                 "type":"string"
              },
              "tls":{
                 "$ref":"#/components/schemas/TlsConfig"
              },
              "pin":{
                 "type":"string"
              },
              "slot":{
                 "type":"integer"
              },
              "access_key":{
                 "type":"string"
              },
              "secret_key":{
                 "type":"string"
              },
              "hsm_order":{
                 "type":"integer"
              },
              "tenant_id":{
                 "type":"string"
              },
              "client_id":{
                 "type":"string"
              },
              "subscription_id":{
                 "type":"string"
              },
              "key_vault_type":{
                 "$ref":"#/components/schemas/AzureKeyVaultType"
              }
           },
           "description":"Configuration for an external key store"
        },
        "HmgKind":{
           "type":"string",
           "description":"The kind of external key store",
           "enum":[
              "AWSKMS",
              "AWSCLOUDHSM",
              "AZUREKEYVAULT",
              "NCIPHER",
              "SAFENET",
              "FORTANIX",
              "FORTANIXFIPSCLUSTER"
           ]
        },
        "AzureKeyVaultType":{
           "type":"string",
           "description":"The type of Azure Key Vault",
           "enum":[
              "STANDARD",
              "PREMIUM"
           ]
        },
        "AzureKeyVaultResponse":{
           "type":"object",
           "properties":{
              "id":{
                 "type":"string"
              },
              "name":{
                 "type":"string"
              },
              "vault_type":{
                 "$ref":"#/components/schemas/AzureKeyVaultType"
              },
              "location":{
                 "type":"string"
              },
              "tags":{
                 "type":"object",
                 "additionalProperties":{
                    "type":"string"
                 },
                 "description":"Map from tag keys to tag vaules"
              },
              "retention":{
                 "type":"integer"
              },
              "uri":{
                 "type":"string"
              }
           },
           "description":"An Azure key vault configuration"
        },
        "ScheduleDeletionRequest":{
           "type":"object",
           "properties":{
              "pending_window_in_days":{
                 "type":"integer"
              }
           },
           "description":"Request to schedule deletion for an AWS KMS key"
        }
     },
     "responses":{
        "AccountListResponse":{
           "description":"An array of accounts",
           "content":{
              "application/json":{
                 "schema":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/Account"
                    }
                 }
              }
           }
        },
        "AccountResponse":{
           "description":"An account",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/Account"
                 }
              }
           }
        },
        "AppCredentialResponse":{
           "description":"An application's credential",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/AppCredentialResponse"
                 }
              }
           }
        },
        "AppListResponse":{
           "description":"An array of applications",
           "content":{
              "application/json":{
                 "schema":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/App"
                    }
                 }
              }
           }
        },
        "AppResponse":{
           "description":"An application",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/App"
                 }
              }
           }
        },
        "ApprovalRequestListResponse":{
           "description":"An array of approval requests",
           "content":{
              "application/json":{
                 "schema":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/ApprovalRequest"
                    }
                 }
              }
           }
        },
        "ApprovalRequestResultResponse":{
           "description":"Result of an approval request",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/ApprovableResult"
                 }
              }
           }
        },
        "AuditLogResponse":{
           "description":"Audit Log",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/AuditLogResponse"
                 }
              }
           }
        },
        "AuthResponse":{
           "description":"Authentication Token",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/AuthResponse"
                 }
              }
           }
        },
        "BatchDecryptResponse":{
           "description":"Array of PlainTexts",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchDecryptResponse"
                 }
              }
           }
        },
        "BatchEncryptResponse":{
           "description":"Array of CipherTexts",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchEncryptResponse"
                 }
              }
           }
        },
        "BatchMacResponse":{
           "description":"Array of MAC responses",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchMacResponse"
                 }
              }
           }
        },
        "BatchSignResponse":{
           "description":"Array of Signatutes",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchSignResponse"
                 }
              }
           }
        },
        "BatchVerifyResponse":{
           "description":"Array of verification result",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchVerifyResponse"
                 }
              }
           }
        },
        "ChildAccountUserListResponse":{
           "description":"An array of users in child account",
           "content":{
              "application/json":{
                 "schema":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/ChildAccountUser"
                    }
                 }
              }
           }
        },
        "ChildAccountUserResponse":{
           "description":"A child account user",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/ChildAccountUser"
                 }
              }
           }
        },
        "ConfirmEmailResponse":{
           "description":"User email",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/ConfirmEmailResponse"
                 }
              }
           }
        },
        "DecryptFinalResponse":{
           "description":"Plaintext",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptFinalResponse"
                 }
              }
           }
        },
        "DecryptInitResponse":{
           "description":"Cipher state",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptInitResponse"
                 }
              }
           }
        },
        "DecryptResponse":{
           "description":"PlainText",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptResponse"
                 }
              }
           }
        },
        "DecryptUpdateResponse":{
           "description":"Plaintext and cipher state",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptUpdateResponse"
                 }
              }
           }
        },
        "DigestResponse":{
           "description":"Digest",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/DigestResponse"
                 }
              }
           }
        },
        "EncryptFinalResponse":{
           "description":"Ciphertext",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptFinalResponse"
                 }
              }
           }
        },
        "EncryptInitResponse":{
           "description":"Cipher state",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptInitResponse"
                 }
              }
           }
        },
        "EncryptResponse":{
           "description":"CipherText",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptResponse"
                 }
              }
           }
        },
        "EncryptUpdateResponse":{
           "description":"Ciphertext and cipher state",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptUpdateResponse"
                 }
              }
           }
        },
        "ErrorResponse":{
           "description":"Unexpected error",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/Error"
                 }
              }
           }
        },
        "ExportComponentsResponse":{
           "description":"Export key components",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/ExportComponentsResponse"
                 }
              }
           }
        },
        "GroupListResponse":{
           "description":"An array of groups",
           "content":{
              "application/json":{
                 "schema":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/Group"
                    }
                 }
              }
           }
        },
        "GroupResponse":{
           "description":"A group",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/Group"
                 }
              }
           }
        },
        "MacGenerateResponse":{
           "description":"MAC",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/MacGenerateResponse"
                 }
              }
           }
        },
        "MacVerifyResponse":{
           "description":"MAC",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/MacVerifyResponse"
                 }
              }
           }
        },
        "MfaChallenge":{
           "description":"Challenge for registring or authenticating with a U2F two factor device",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/MfaChallenge"
                 }
              }
           }
        },
        "PluginInvokeResponse":{
           "description":"Result object from plugin execution",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/PluginInvokeResponse"
                 }
              }
           }
        },
        "PluginListResponse":{
           "description":"An array of plugins",
           "content":{
              "application/json":{
                 "schema":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/Plugin"
                    }
                 }
              }
           }
        },
        "PluginResponse":{
           "description":"A plugin",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/Plugin"
                 }
              }
           }
        },
        "RecoveryCodes":{
           "description":"Backup recovery codes for two factor authentication",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/RecoveryCodes"
                 }
              }
           }
        },
        "SelectAccountResponse":{
           "description":"Additional data returned when selecting an account",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/SelectAccountResponse"
                 }
              }
           }
        },
        "SignResponse":{
           "description":"Signature",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/SignResponse"
                 }
              }
           }
        },
        "StatsResponse":{
           "description":"Statistics Data",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/StatsResponse"
                 }
              }
           }
        },
        "StreamDecryptResponse":{
           "description":"Stream of decrypt response frames",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptResponseFrame"
                 }
              }
           }
        },
        "StreamEncryptResponse":{
           "description":"Stream of encrypt response frames",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptResponseFrame"
                 }
              }
           }
        },
        "UserAccountResponse":{
           "description":"A user's accounts and flags for each account",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/UserAccountMap"
                 }
              }
           }
        },
        "UserListResponse":{
           "description":"An array of users",
           "content":{
              "application/json":{
                 "schema":{
                    "type":"array",
                    "items":{
                       "$ref":"#/components/schemas/User"
                    }
                 }
              }
           }
        },
        "UserResponse":{
           "description":"A user",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/User"
                 }
              }
           }
        },
        "ValidateTokenResponse":{
           "description":"User email",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/ValidateTokenResponse"
                 }
              }
           }
        },
        "VerifyResponse":{
           "description":"Verification",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/VerifyResponse"
                 }
              }
           }
        },
        "VersionResponse":{
           "description":"Version information",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/VersionResponse"
                 }
              }
           }
        },
        "WrapKeyResponse":{
           "description":"Wrapped key value",
           "content":{
              "application/json":{
                 "schema":{
                    "$ref":"#/components/schemas/WrapKeyResponse"
                 }
              }
           }
        }
     },
     "parameters":{
        "KeyId":{
           "name":"key-id",
           "in":"path",
           "description":"kid of security object",
           "required":true,
           "schema":{
              "type":"string"
           }
        },
        "AppId":{
           "name":"app-id",
           "in":"path",
           "description":"Application Identifier",
           "required":true,
           "schema":{
              "type":"string"
           }
        },
        "PluginId":{
           "name":"plugin-id",
           "in":"path",
           "description":"Plugin Identifier",
           "required":true,
           "schema":{
              "type":"string"
           }
        },
        "GroupId":{
           "name":"group-id",
           "in":"path",
           "description":"Group Identifier",
           "required":true,
           "schema":{
              "type":"string"
           }
        },
        "AccountId":{
           "name":"account-id",
           "in":"path",
           "description":"Account Identifier",
           "required":true,
           "schema":{
              "type":"string"
           }
        },
        "UserId":{
           "name":"user-id",
           "in":"path",
           "description":"User Identifier",
           "required":true,
           "schema":{
              "type":"string"
           }
        },
        "RequestId":{
           "name":"request-id",
           "in":"path",
           "description":"Approval Request Identifier",
           "required":true,
           "schema":{
              "type":"string"
           }
        },
        "Size":{
           "name":"size",
           "in":"query",
           "description":"Maximum number of entries to return. The input value can't be greater than 1000. If a higher value is specifed, only 1000 results are returned.\n",
           "schema":{
              "type":"integer"
           }
        },
        "From":{
           "name":"from",
           "in":"query",
           "description":"For pagination, starting offset",
           "schema":{
              "type":"integer"
           }
        },
        "ActionType":{
           "name":"action_type",
           "in":"query",
           "description":"Event action type",
           "schema":{
              "type":"string",
              "enum":[
                 "Apps",
                 "Users"
              ]
           }
        },
        "ActorType":{
           "name":"actor_type",
           "in":"query",
           "description":"Event actor type",
           "schema":{
              "type":"string",
              "enum":[
                 "Administrative",
                 "Auth",
                 "CryptoOperation"
              ]
           }
        },
        "ActorId":{
           "name":"actor_id",
           "in":"query",
           "description":"Actor (User or App) Identifier",
           "schema":{
              "type":"string"
           }
        },
        "ObjectId":{
           "name":"object_id",
           "in":"query",
           "description":"Object (User or App) Identifier for event",
           "schema":{
              "type":"string"
           }
        },
        "Severity":{
           "name":"severity",
           "in":"query",
           "description":"Event severity type",
           "schema":{
              "type":"string",
              "enum":[
                 "Info",
                 "Warning",
                 "Error",
                 "Critical"
              ]
           }
        },
        "RangeFrom":{
           "name":"range_from",
           "in":"query",
           "description":"Starting time for search , this is EPOCH value",
           "schema":{
              "type":"integer"
           }
        },
        "RangeTo":{
           "name":"range_to",
           "in":"query",
           "description":"Ending time for search , this is EPOCH value",
           "schema":{
              "type":"integer"
           }
        },
        "TopCount":{
           "name":"top_count",
           "in":"query",
           "description":"Maximum top count for statistics query",
           "schema":{
              "type":"integer"
           }
        },
        "NumPoints":{
           "name":"num_points",
           "in":"query",
           "description":"Number of data points desired",
           "schema":{
              "type":"integer"
           }
        }
     },
     "requestBodies":{
        "ExportRequest":{
           "description":"Request to export a security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SobjectDescriptor"
                 }
              }
           },
           "required":true
        },
        "ExportSobjectComponentsRequest":{
           "description":"Request to export a security object components",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ExportSobjectComponentsRequest"
                 }
              }
           },
           "required":true
        },
        "ImportSobjectComponentsRequest":{
           "description":"Request to import a security object components",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ImportSobjectComponentsRequest"
                 }
              }
           },
           "required":true
        },
        "SobjectRequest":{
           "description":"Request to create, update, or import security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SobjectRequest"
                 }
              }
           },
           "required":true
        },
        "RevertRequest":{
           "description":"Request to create, update, or import security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SobjectRequest"
                 }
              }
           },
           "required":true
        },
        "RevocationReason":{
           "description":"Reason to revoke a security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/RevocationReason"
                 }
              }
           },
           "required":true
        },
        "PersistTransientKeyRequest":{
           "description":"Persist transient key request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/PersistTransientKeyRequest"
                 }
              }
           },
           "required":true
        },
        "EncryptRequest":{
           "description":"Encryption request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptRequest"
                 }
              }
           },
           "required":true
        },
        "EncryptRequestEx":{
           "description":"Encryption request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptRequestEx"
                 }
              }
           },
           "required":true
        },
        "BatchEncryptRequest":{
           "description":"Batch Encryption request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchEncryptRequest"
                 }
              }
           },
           "required":true
        },
        "EncryptInitRequest":{
           "description":"Multi-part encryption initialization request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptInitRequest"
                 }
              }
           },
           "required":true
        },
        "EncryptInitRequestEx":{
           "description":"Multi-part encryption initialization request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptInitRequestEx"
                 }
              }
           },
           "required":true
        },
        "EncryptUpdateRequest":{
           "description":"Multi-part encryption",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptUpdateRequest"
                 }
              }
           },
           "required":true
        },
        "EncryptUpdateRequestEx":{
           "description":"Multi-part encryption",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptUpdateRequestEx"
                 }
              }
           },
           "required":true
        },
        "EncryptFinalRequest":{
           "description":"Finish multi-part encryption",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptFinalRequest"
                 }
              }
           },
           "required":true
        },
        "EncryptFinalRequestEx":{
           "description":"Finish multi-part encryption",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptFinalRequestEx"
                 }
              }
           },
           "required":true
        },
        "StreamEncryptRequest":{
           "description":"Stream of encrypt request frames",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/EncryptRequestFrame"
                 }
              }
           },
           "required":true
        },
        "DecryptRequest":{
           "description":"Decryption request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptRequest"
                 }
              }
           },
           "required":true
        },
        "DecryptRequestEx":{
           "description":"Decryption request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptRequestEx"
                 }
              }
           },
           "required":true
        },
        "BatchDecryptRequest":{
           "description":"Batch decryption request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchDecryptRequest"
                 }
              }
           },
           "required":true
        },
        "DecryptInitRequest":{
           "description":"Multi-part decryption initialization request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptInitRequest"
                 }
              }
           },
           "required":true
        },
        "DecryptInitRequestEx":{
           "description":"Multi-part decryption initialization request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptInitRequestEx"
                 }
              }
           },
           "required":true
        },
        "DecryptUpdateRequest":{
           "description":"Multi-part decryption",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptUpdateRequest"
                 }
              }
           },
           "required":true
        },
        "DecryptUpdateRequestEx":{
           "description":"Multi-part decryption",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptUpdateRequestEx"
                 }
              }
           },
           "required":true
        },
        "DecryptFinalRequest":{
           "description":"Finish multi-part decryption",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptFinalRequest"
                 }
              }
           },
           "required":true
        },
        "DecryptFinalRequestEx":{
           "description":"Finish multi-part decryption",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptFinalRequestEx"
                 }
              }
           },
           "required":true
        },
        "StreamDecryptRequest":{
           "description":"Stream of decrypt request frames",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DecryptRequestFrame"
                 }
              }
           },
           "required":true
        },
        "SignRequest":{
           "description":"Signature request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SignRequest"
                 }
              }
           },
           "required":true
        },
        "SignRequestEx":{
           "description":"Signature request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SignRequestEx"
                 }
              }
           },
           "required":true
        },
        "BatchSignRequest":{
           "description":"Batch Sign request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchSignRequest"
                 }
              }
           },
           "required":true
        },
        "VerifyRequest":{
           "description":"Verification request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/VerifyRequest"
                 }
              }
           },
           "required":true
        },
        "VerifyRequestEx":{
           "description":"Verification request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/VerifyRequestEx"
                 }
              }
           },
           "required":true
        },
        "BatchVerifyRequest":{
           "description":"Batch Verify request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchVerifyRequest"
                 }
              }
           },
           "required":true
        },
        "DigestRequest":{
           "description":"Digest request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DigestRequest"
                 }
              }
           },
           "required":true
        },
        "ObjectDigestRequest":{
           "description":"Object digest request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ObjectDigestRequest"
                 }
              }
           },
           "required":true
        },
        "VerifyKcvRequest":{
           "description":"Verify KCV request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/VerifyKcvRequest"
                 }
              }
           },
           "required":true
        },
        "VerifyKcvResponse":{
           "description":"Verify KCV response",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/VerifyKcvResponse"
                 }
              }
           },
           "required":true
        },
        "MacGenerateRequest":{
           "description":"MAC generation request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/MacGenerateRequest"
                 }
              }
           },
           "required":true
        },
        "MacGenerateRequestEx":{
           "description":"MAC generation request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/MacGenerateRequestEx"
                 }
              }
           },
           "required":true
        },
        "BatchMacRequest":{
           "description":"Batch MAC request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchMacRequest"
                 }
              }
           },
           "required":true
        },
        "BatchMacResponse":{
           "description":"Batch MAC response",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchMacResponse"
                 }
              }
           },
           "required":true
        },
        "MacVerifyRequest":{
           "description":"MAC Verify request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/MacVerifyRequest"
                 }
              }
           },
           "required":true
        },
        "MacVerifyRequestEx":{
           "description":"MAC Verify request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/MacVerifyRequestEx"
                 }
              }
           },
           "required":true
        },
        "BatchMacVerifyRequest":{
           "description":"Batch MAC verify request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/BatchMacVerifyRequest"
                 }
              }
           },
           "required":true
        },
        "AppRequest":{
           "description":"Properties of application to create",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/AppRequest"
                 }
              }
           },
           "required":true
        },
        "PluginRequest":{
           "description":"Properties of plugin to create",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/PluginRequest"
                 }
              }
           },
           "required":true
        },
        "PluginInvokeRequest":{
           "description":"Object to be passed to plugin as input",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/PluginInvokeRequest"
                 }
              }
           },
           "required":true
        },
        "GroupRequest":{
           "description":"Name of group",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/GroupRequest"
                 }
              }
           },
           "required":true
        },
        "AccountRequest":{
           "description":"Properties to assign to Account.",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/AccountRequest"
                 }
              }
           },
           "required":true
        },
        "UserRequest":{
           "description":"Name of user",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/UserRequest"
                 }
              }
           },
           "required":true
        },
        "SignupRequest":{
           "description":"Email address of user",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SignupRequest"
                 }
              }
           },
           "required":true
        },
        "DeriveKeyRequest":{
           "description":"Name of security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DeriveKeyRequest"
                 }
              }
           },
           "required":true
        },
        "DeriveKeyRequestEx":{
           "description":"Name of security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/DeriveKeyRequestEx"
                 }
              }
           },
           "required":true
        },
        "AgreeKeyRequest":{
           "description":"Template of the agreed-upon security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/AgreeKeyRequest"
                 }
              }
           },
           "required":true
        },
        "PasswordChangeRequest":{
           "description":"Password change request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/PasswordChangeRequest"
                 }
              }
           },
           "required":true
        },
        "SelectAccountRequest":{
           "description":"Select Account Request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SelectAccountRequest"
                 }
              }
           },
           "required":true
        },
        "ProcessInviteRequest":{
           "description":"Process account invitation (both accepts and rejects)",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ProcessInviteRequest"
                 }
              }
           },
           "required":true
        },
        "ForgotPasswordRequest":{
           "description":"Initiate forgot password sequrence",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ForgotPasswordRequest"
                 }
              }
           },
           "required":true
        },
        "PasswordResetRequest":{
           "description":"Reset password",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/PasswordResetRequest"
                 }
              }
           },
           "required":true
        },
        "ValidateTokenRequest":{
           "description":"Validate token",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ValidateTokenRequest"
                 }
              }
           },
           "required":true
        },
        "WrapKeyRequest":{
           "description":"Wrap key request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/WrapKeyRequest"
                 }
              }
           },
           "required":true
        },
        "WrapKeyRequestEx":{
           "description":"Wrap key request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/WrapKeyRequestEx"
                 }
              }
           },
           "required":true
        },
        "UnwrapKeyRequest":{
           "description":"Unwrap key request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/UnwrapKeyRequest"
                 }
              }
           },
           "required":true
        },
        "UnwrapKeyRequestEx":{
           "description":"Unwrap key request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/UnwrapKeyRequestEx"
                 }
              }
           },
           "required":true
        },
        "ConfirmEmailRequest":{
           "description":"Validate user's email",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ConfirmEmailRequest"
                 }
              }
           },
           "required":true
        },
        "ApprovalRequestRequest":{
           "description":"Request to create an approval request.",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ApprovalRequestRequest"
                 }
              }
           },
           "required":true
        },
        "AppResetSecretRequest":{
           "description":"Decryption request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/AppResetSecretRequest"
                 }
              }
           },
           "required":true
        },
        "ChildAccountUserRequest":{
           "description":"User in child account",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ChildAccountUserRequest"
                 }
              }
           },
           "required":true
        },
        "ApproveRequest":{
           "description":"Approve an approval request",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ApproveRequest"
                 }
              }
           },
           "required":false
        },
        "SecurityObjectKcvRequest":{
           "description":"Request to export a security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SobjectDescriptor"
                 }
              }
           },
           "required":true
        },
        "ScheduleDeletionRequest":{
           "description":"Request to schedule deletion for an AWS KMS key",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/ScheduleDeletionRequest"
                 }
              }
           },
           "required":true
        },
        "HmgCheckRequest":{
           "description":"Request to check validity and reachability of an external configuration",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/HmgConfig"
                 }
              }
           },
           "required":true
        },
        "GetSecurityObjectRequest":{
           "description":"Request to get a security object",
           "content":{
              "*/*":{
                 "schema":{
                    "$ref":"#/components/schemas/SobjectDescriptor"
                 }
              }
           },
           "required":true
        }
     },
     "securitySchemes":{
        "basicAuth":{
           "type":"http",
           "description":"HTTPS Basic Authentication. Composed of `app-id` and `app-secret`",
           "scheme":"basic"
        },
        "bearerToken":{
           "type":"apiKey",
           "description":"This needs to passed in every operation once authenticated",
           "name":"Authorization",
           "in":"header"
        }
     }
  }
}
